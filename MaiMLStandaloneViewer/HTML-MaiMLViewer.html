<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>MaiML Viewer</title>
    <style>
        :root {
            --toolbar-h: 56px;
            --bg: #fffdfc;
            --surface: #fffdfc;
            --ink: #222;
            --muted: #666;
            --border: #c5c5c5;
            --accent: #1976d2;
            --accent2: #2a7;
            --warn: #e91e63;
            --table-head: #eef4f9;
            --table-border: #e0e0e0;
            --chip: #ffe699;
            --chip-ink: #222;
            --code-bg: #efeceb;
            --code-ink: #25252f;
            --link: #25252f;
            --btn-bg: #f5f5f5;
            --btn-ink: #222;
            --btn-border: #ccc;
            --btn-hover-bg: #328bff;
        }

        :root[data-theme="dark"] {
            --bg: #25252f;
            --surface: #2c2c36;
            --ink: #e8edf2;
            --muted: #9aa4b2;
            --border: #4a4f5a;
            --accent: #5aa3ff;
            --accent2: #3ddc97;
            --warn: #ff5c93;
            --table-head: #4a4a58;
            --table-border: #5f6677;
            --chip: #f6d65b;
            --chip-ink: #222;
            --code-bg: #15151f;
            --code-ink: #e8edf2;
            --link: #5aa3ff;
            --btn-bg: #51515a;
            --btn-ink: #e8edf2;
            --btn-border: #767688;
            --btn-hover-bg: #5aa3ff;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic UI", "Yu Gothic", sans-serif;
            color: var(--ink);
            background: var(--bg);
            display: flex;
            flex-direction: column;
        }

        header#toolbar {
            position: sticky;
            top: 0;
            z-index: 10;
            height: var(--toolbar-h);
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: .5rem;
            padding: .4rem .6rem;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
            flex-shrink: 0;
        }

        header #title {
            font-weight: 600;
            margin-right: .5rem
        }

        header .spacer {
            flex: 1 1 auto
        }

        header input[type=file] {
            display: none
        }

        .btn,
        .filelabel {
            background: var(--btn-bg);
            color: var(--btn-ink);
            border: 1px solid var(--btn-border);
            border-radius: 8px;
            padding: .25rem .5rem;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .btn:hover,
        .filelabel:hover {
            background: var(--btn-hover-bg);
        }

        .btn.primary {
            border-color: var(--accent);
            color: #fff;
            background: var(--accent)
        }

        .btn:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        .file-name {
            font-size: 12px;
            color: var(--muted);
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chk {
            display: inline-flex;
            align-items: center;
            border-radius: 6px;
            font-size: 13px;
        }

        .seg {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden
        }

        .seg button {
            border: 0;
            background: var(--surface);
            color: var(--ink);
            padding: .25rem .5rem;
            cursor: pointer;
            font-size: 12px
        }

        .seg button.active {
            background: var(--accent);
            color: #fff
        }

        #mainContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #topSection {
            display: flex;
            height: 50%;
            min-height: 200px;
        }

        #horizontalSeparator {
            height: 5px;
            cursor: ns-resize;
            background: #ccc;
            flex-shrink: 0;
        }

        #bottomSection {
            flex: 1;
            min-height: 150px;
            overflow: hidden;
        }

        #stageWrap {
            /* flex: 1; */
            flex: 1 1 50%;
            position: relative;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        svg#stage {
            width: 100%;
            height: 100%;
            background: var(--bg)
        }

        #grid {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: .35;
            background-image: linear-gradient(to right, #0000 9px, var(--border) 10px), linear-gradient(to bottom, #0000 9px, var(--border) 10px);
            background-size: 10px 10px;
            display: none
        }

        #verticalSeparator {
            flex-shrink: 0;
            width: 5px;
            cursor: ew-resize;
            background: #ccc;
        }

        #metadataPanel {
            /* width: 400px; */
            flex: 1 1 50%;
            min-width: 200px;
            background: var(--surface);
            padding: .8rem;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #document-info {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: .8rem;
            font-size: 15px;
        }

        #document-info h3 {
            margin: 0 0 .8rem 0;
            font-size: 15px;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: .5rem;
        }

        #document-info table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        #document-info th,
        #document-info td {
            border: 1px solid var(--table-border);
            padding: .4rem .5rem;
            vertical-align: top;
            text-align: left;
        }

        #document-info th {
            background: var(--table-head);
            font-weight: 600;
            width: 1%;
            white-space: nowrap;
        }

        #document-info .empty-state {
            color: var(--muted);
            font-style: italic;
            padding: 2rem 1rem;
            text-align: center;
            background: var(--bg);
            border-radius: 6px;
        }

        /* 1. „Éë„Éç„É´Ëá™‰Ωì„ÅÆ„Çπ„ÇØ„É≠„Éº„É´„ÇíÊ≠¢„ÇÅ„ÄÅ‰∏≠Ë∫´„ÇíÁ∏¶‰∏¶„Å≥„Å´„Åô„Çã */
        #detailsPanel {
            background: var(--surface);
            padding: 0;
            /* „ÉÑ„Éº„É´„Éê„Éº„ÇíÁ´Ø„Åæ„ÅßÂ∫É„Åí„Çã„Åü„ÇÅ‰∏ÄÊó¶ 0 „Å´„Åó„ÄÅ‰∏≠Ë∫´„ÅßË™øÊï¥„Åó„Åæ„Åô */
            overflow: hidden;
            /* ÂÖ®‰Ωì„ÅÆ„Çπ„ÇØ„É≠„Éº„É´„ÇíÁ¶ÅÊ≠¢ */
            border-top: 1px solid var(--border);
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* 2. StatsÔºàNot Loaded„Å™„Å©Ôºâ„Å®„ÉÑ„Éº„É´„Éê„Éº„ÇíÂõ∫ÂÆö„Ç®„É™„Ç¢„Å´„Åô„Çã */
        #stats {
            font-size: 12px;
            color: var(--muted);
            margin: .8rem .8rem .6rem .8rem;
            /* padding„ÅÆ‰ª£„Çè„Çä„Å´margin„Åß‰ΩôÁôΩË™øÊï¥ */
            padding: .5rem .6rem;
            background: var(--bg);
            border-radius: 6px;
            flex-shrink: 0;
            /* ÊΩ∞„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´Âõ∫ÂÆö */
        }

        #detailsPanel .toolbar {
            position: sticky;
            top: 0;
            background: var(--surface);
            z-index: 10;
            padding: 0 .8rem .8rem .8rem;
            /* ‰∏ã„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Å®„ÅÆÈñìÈöî */
            margin: 0;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            /* ÊΩ∞„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´Âõ∫ÂÆö */
        }

        /* 3. Ë©≥Á¥∞„ÅåË°®Á§∫„Åï„Çå„Çã #meta „Å†„Åë„Çí„Çπ„ÇØ„É≠„Éº„É´„Åï„Åõ„Çã */
        #meta {
            flex-grow: 1;
            overflow-y: auto;
            /* „Åì„Åì„Å´„Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÂá∫„Åô */
            overflow-x: hidden;
            padding: .8rem;
            /* „Åì„Åì„ÅßÂÖÉ„ÄÖ„ÅÆ„Éë„Éç„É´„ÅÆ‰ΩôÁôΩ„ÇíÂÜçÁèæ */
        }


        .hint {
            font-size: 12px;
            color: var(--muted);
            margin: .25rem 0
        }

        .warn {
            color: var(--warn)
        }

        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            margin: .35rem 0;
        }

        table.kv {
            width: 100%;
            min-width: 100px;
            border-collapse: collapse;
            font-size: 13px;
        }

        table.kv th,
        table.kv td {
            border: 1px solid var(--table-border);
            padding: .35rem .5rem;
            vertical-align: top;
            white-space: nowrap;
        }

        table.kv th {
            background: var(--table-head);
            text-align: left;
            width: 1%;
            white-space: nowrap;
        }

        table.kv td {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        table.kv td.key-cell {
            position: relative;
        }

        table.kv td.key-cell .key-text {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        table.kv td.key-cell:hover .key-text {
            overflow: visible;
            white-space: normal;
            word-break: break-all;
            background: var(--surface);
            position: relative;
            z-index: 10;
            padding: 0.2rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .nodes .place circle {
            fill: var(--surface);
            stroke: var(--accent2);
            stroke-width: 2
        }

        .nodes .transition rect {
            fill: var(--surface);
            stroke: var(--accent);
            stroke-width: 2;
            rx: 4;
            ry: 4
        }

        line.link {
            stroke: var(--muted);
            stroke-width: 1.5
        }

        .label {
            font-size: 12px;
            fill: var(--ink);
            pointer-events: none
        }

        .node.selected :is(circle, rect) {
            stroke: var(--warn)
        }

        details.meta {
            border: 1px solid var(--table-border);
            border-radius: 8px;
            padding: .25rem .5rem;
            margin: .5rem 0;
            background: var(--surface)
        }

        details.meta summary {
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            gap: .5rem
        }

        details.meta summary::-webkit-details-marker {
            display: none
        }

        .badge {
            display: inline-block;
            font-size: 14px;
            padding: .1rem .4rem;
            border-radius: 999px;
            background: var(--chip);
            color: var(--chip-ink);
        }

        pre.xml-snip {
            background: var(--code-bg);
            color: var(--code-ink);
            padding: .6rem .8rem;
            border-radius: 8px;
            overflow: auto;
            white-space: pre;
            position: relative;
        }

        .insertion-container {
            position: relative;
            margin: .5rem 0;
        }

        .insertion-upload-btn {
            position: absolute;
            top: .5rem;
            right: .5rem;
            background: var(--accent);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: .3rem .6rem;
            cursor: pointer;
            font-size: 11px;
            z-index: 1;
            transition: all 0.2s;
        }

        .insertion-upload-btn:hover {
            background: var(--accent2);
            transform: scale(1.05);
        }

        .insertion-upload-btn.has-file {
            background: var(--accent2);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: .5rem;
            border-bottom: 2px solid var(--border);
        }

        .modal-header h3 {
            margin: 0;
            color: var(--ink);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--muted);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--border);
            color: var(--ink);
        }

        .modal-body {
            color: var(--ink);
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            margin: 1rem 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--bg);
        }

        .upload-area.dragover {
            border-color: var(--accent2);
            background: var(--bg);
        }

        .format-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: .8rem;
            margin: 1rem 0;
        }

        .format-option {
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--surface);
        }

        .format-option:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .format-option.selected {
            border-color: var(--accent);
            background: var(--accent);
            color: #fff;
        }

        .format-icon {
            font-size: 32px;
            margin-bottom: .5rem;
        }

        .preview-area {
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            min-height: 300px;
            background: var(--bg);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
        }

        .preview-area img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }

        .preview-area canvas {
            max-width: 100%;
            height: auto;
        }

        .toolbar {
            display: flex;
            gap: .5rem;
            align-items: center;
            margin: .25rem 0 .8rem
        }

        .toolbar .btn {
            font-size: 12px;
            padding: .25rem .5rem
        }

        .value-cell-scroll {
            max-height: 3em;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: normal;
            word-wrap: break-word;
            padding: 2px 4px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--surface);
            color: var(--ink);
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="file"],
        textarea,
        select {
            background: var(--surface);
            color: var(--ink);
            border: 1px solid var(--border);
        }

        input[type="checkbox"],
        input[type="radio"] {
            accent-color: var(--accent);
        }

        h3.section-title {
            margin: 1rem 0 .5rem 0;
            font-size: 14px;
            color: var(--accent);
            border-bottom: 2px solid var(--border);
            padding-bottom: .3rem;
        }

        line.link {
            stroke: var(--muted);
            stroke-width: 1.5
        }

        line.link.ref-link {
            stroke: var(--muted);
            stroke-width: 1.2;
            stroke-dasharray: 5, 3;
            opacity: 0.4;
        }

        #aiSummaryModal .modal-content {
            width: 650px;
            max-width: 90vw;
            height: 70vh;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #aiSummaryModal .modal-body {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
            padding-top: 0.5rem;
        }

        #aiSummaryTarget {
            max-height: 150px !important;
            overflow-y: auto !important;
            flex-shrink: 0;
        }

        .ai-summary-result-container {
            flex-grow: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            margin-bottom: 0.5rem;
        }

        #aiSummaryResult {
            flex-grow: 1;
            overflow-y: auto;
            padding: .5rem;
            border: 1px solid var(--border);
            background: var(--bg);
            border-radius: 4px;
            white-space: pre-wrap;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3 {
            color: var(--accent);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }

        .markdown-content h1 {
            font-size: 1.5em;
        }

        .markdown-content h2 {
            font-size: 1.3em;
        }

        .markdown-content h3 {
            font-size: 1.1em;
        }

        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.5rem 0;
            font-size: 13px;
        }

        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid var(--table-border);
            padding: 0.4rem 0.6rem;
            text-align: left;
        }

        .markdown-content table th {
            background: var(--table-head);
            font-weight: 600;
        }

        .markdown-content p {
            margin: 0.5rem 0;
            line-height: 1.6;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .markdown-content code {
            background: var(--code-bg);
            color: var(--code-ink);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .markdown-content pre {
            background: var(--code-bg);
            color: var(--code-ink);
            padding: 0.8rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
        }

        .markdown-content strong {
            font-weight: 600;
            color: var(--accent);
        }

        .markdown-content em {
            font-style: italic;
            color: var(--muted);
        }

        .markdown-content blockquote {
            border-left: 3px solid var(--accent);
            padding-left: 1rem;
            margin: 0.5rem 0;
            color: var(--muted);
        }

        .ai-disclaimer {
            margin-top: 1.5rem;
            padding: 0.8rem;
            background: var(--bg);
            border-left: 3px solid var(--warn);
            border-radius: 4px;
            font-size: 12px;
            color: var(--muted);
            font-style: italic;
        }

        .ai-disclaimer::before {
            content: "‚ö†Ô∏è ";
            font-style: normal;
        }

        .prompt-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.8rem;
            align-items: center;
        }

        .prompt-selector label {
            font-weight: 600;
            white-space: nowrap;
        }

        .prompt-selector select {
            flex: 1;
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 13px;
        }
    </style>
</head>

<body>
    <header id="toolbar">
        <div id="title">MaiML Viewer</div>
        <button class="btn" id="openFileBtn">üìÇUPLOAD‚Ä¶</button>
        <button class="btn" id="dagreBtn">Dagre Layout</button>
        <button class="btn" id="auto">Auto Layout</button>
        <button class="btn" id="reset">Reset Position</button>
        <label class="chk"><input checked="" id="dragMode" type="checkbox" /> Drag Edit</label>
        <label class="chk"><input id="showGrid" type="checkbox" /> Show Grid</label>
        <label class="chk"><input id="snapGrid" type="checkbox" /> Snap to Grid</label>
        <div class="spacer"></div>
        <button class="btn" id="themeBtn" title="Light/Dark Toggle">üåô Theme</button>
    </header>

    <div id="mainContainer">
        <div id="topSection">
            <div id="stageWrap">
                <div id="grid"></div>
                <svg id="stage"></svg>
            </div>
            <div id="verticalSeparator"></div>
            <div id="metadataPanel">
                <div id="document-info">
                    <h3>üìÑ Document Metadata</h3>
                    <div class="empty-state">Select a file to display metadata</div>
                </div>
            </div>
        </div>

        <div id="horizontalSeparator"></div>

        <div id="bottomSection">
            <div id="detailsPanel">
                <div id="stats">Not Loaded</div>
                <div class="toolbar">
                    <button class="btn" id="expandAll">üîªExpand All</button>
                    <button class="btn" id="collapseAll">üî∫Collapse All</button>
                    <div class="seg" id="metaSource">
                        <button class="active" data-mode="both">Both</button>
                        <button data-mode="template">Template</button>
                        <button data-mode="instance">Instance</button>
                    </div>
                </div>
                <div id="meta"></div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="uploadModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Upload File</h3>
                <button class="modal-close">√ó</button>
            </div>
            <div class="modal-body">
                <div class="upload-area" id="uploadArea">
                    <div style="font-size:48px; margin-bottom:1rem;">üìÅ</div>
                    <p>Drag & Drop a file<br />or<br />Click to select</p>
                    <input accept="image/*,.tif,.tiff,.csv,.json,.txt" id="insertionFile" style="display:none;"
                        type="file" />
                </div>
                <div id="formatSelector" style="display:none;">
                    <h4>Select Display Format</h4>
                    <div class="format-selector">
                        <div class="format-option" data-format="image">
                            <div class="format-icon">üñºÔ∏è</div>
                            <div>Image</div>
                        </div>
                        <div class="format-option" data-format="chart">
                            <div class="format-icon">üìä</div>
                            <div>Chart</div>
                        </div>
                        <div class="format-option" data-format="table">
                            <div class="format-icon">üìã</div>
                            <div>Table</div>
                        </div>
                        <div class="format-option" data-format="text">
                            <div class="format-icon">üìù</div>
                            <div>Text</div>
                        </div>
                    </div>
                </div>
                <div class="preview-area" id="previewArea" style="display:none;">
                    <div id="previewContent"></div>
                </div>
                <div style="display:flex; gap:.5rem; justify-content:flex-end; margin-top:1rem;">
                    <button class="btn" id="cancelBtn">Cancel</button>
                    <button class="btn primary" id="applyBtn" style="display:none;">Apply</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="aiSummaryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>AI Summary</h3>
                <button class="modal-close" id="aiSummaryClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="prompt-selector">
                    <!-- AI„É¢„Éá„É´Á∑®ÈõÜ -->
                    <label>Gemini API Model:</label>
                    <input id="modelName" type="text" value="gemini-2.5-flash-lite" />
                    <!-- Ë¶ÅÁ¥Ñ„É¨„Éô„É´ÈÅ∏Êäû -->
                    <label>Summary Type:</label>
                    <select id="promptTemplate">
                        <option value="quick" selected>Quick Summary</option>
                        <option value="standard">Standard Summary</option>
                        <option value="detailed">Detailed Analysis</option>
                    </select>
                </div>

                <h4>Input Text (to be summarized)</h4>
                <pre id="aiSummaryTarget"
                    style="max-height:100px; overflow-y:auto; padding:.5rem; border:1px solid var(--border); background:var(--bg); border-radius:4px;"></pre>

                <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-top:0.5rem;">
                    <h4>AI Summary Result</h4>
                    <div style="display:flex; gap: 5px;">
                        <button class="btn" id="saveSummaryBtn" style="border-radius:4px 0 0 4px;">üíæ Save
                            (.md)</button>
                        <button class="btn" id="copySummaryBtn" style="border-radius:0 4px 4px 0;">üìã Copy</button>
                    </div>
                </div>
                <div class="ai-summary-result-container">
                    <div id="aiSummaryResult" class="markdown-content">Generating summary...</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        ; (function () {
            const svg = d3.select('#stage');
            const gRoot = svg.append('g');
            const gLinks = gRoot.append('g').attr('class', 'links');
            const gNodes = gRoot.append('g').attr('class', 'nodes');
            svg.call(d3.zoom().scaleExtent([0.25, 6]).on('zoom', (e) => gRoot.attr('transform', e.transform)));

            svg.append('defs').append('marker')
                .attr('id', 'arrow')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 24)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#888');

            let nodes = [], links = [];
            let byId = new Map();
            let simulation = null, netKey = 'default';

            const placeToTemplates = new Map();
            const templateById = new Map();
            const templateToInstances = new Map();
            const instances = [];
            const insertionFiles = new Map();

            // „Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥Èñ¢ÈÄ£„ÅÆ„Éá„Éº„Çø
            const instructionById = new Map();
            const transitionToInstructions = new Map();
            const eventsByInstructionId = new Map();

            const $grid = document.getElementById('grid');
            const $stats = document.getElementById('stats');
            const $meta = document.getElementById('meta');
            const $seg = document.getElementById('metaSource');
            const $themeBtn = document.getElementById('themeBtn');
            const $documentInfo = document.getElementById('document-info');
            let metaMode = 'both';

            const $modal = document.getElementById('uploadModal');
            const $uploadArea = document.getElementById('uploadArea');
            const $insertionFile = document.getElementById('insertionFile');
            const $formatSelector = document.getElementById('formatSelector');
            const $previewArea = document.getElementById('previewArea');
            const $previewContent = document.getElementById('previewContent');
            const $cancelBtn = document.getElementById('cancelBtn');
            const $applyBtn = document.getElementById('applyBtn');
            const $openFileBtn = document.getElementById('openFileBtn');

            let currentInsertionId = null;
            let currentFile = null;
            let selectedFormat = null;

            // Theme
            const THEME_KEY = 'maiml-theme';
            initTheme();
            $themeBtn.addEventListener('click', () => {
                const cur = document.documentElement.getAttribute('data-theme');
                const next = cur === 'dark' ? 'light' : 'dark';
                applyTheme(next);
                localStorage.setItem(THEME_KEY, next);
            });

            function initTheme() {
                const saved = localStorage.getItem(THEME_KEY);
                if (saved) { applyTheme(saved); return; }
                const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                applyTheme(prefersDark ? 'dark' : 'light');
            }

            function applyTheme(mode) {
                document.documentElement.setAttribute('data-theme', mode === 'dark' ? 'dark' : 'light');
            }

            // Resizers
            setupHorizontalResizer();
            setupVerticalResizer();

            function setupHorizontalResizer() {
                const separator = document.getElementById('horizontalSeparator');
                let isResizing = false;

                separator.addEventListener('mousedown', () => { isResizing = true; });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const container = document.getElementById('mainContainer');
                    const topSection = document.getElementById('topSection');
                    const totalHeight = container.clientHeight;
                    const minTop = 200;
                    const minBottom = 150;

                    let topHeight = e.clientY - container.offsetTop - document.getElementById('toolbar').offsetHeight;

                    if (topHeight < minTop) topHeight = minTop;
                    if (totalHeight - topHeight - separator.offsetHeight < minBottom)
                        topHeight = totalHeight - minBottom - separator.offsetHeight;

                    topSection.style.height = `${topHeight}px`;
                    topSection.style.flex = 'none';
                });

                document.addEventListener('mouseup', () => { isResizing = false; });
            }

            function setupVerticalResizer() {
                const separator = document.getElementById('verticalSeparator');
                let isResizing = false;

                separator.addEventListener('mousedown', () => { isResizing = true; });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const topSection = document.getElementById('topSection');
                    const stageWrap = document.getElementById('stageWrap');
                    const metadataPanel = document.getElementById('metadataPanel');
                    const totalWidth = topSection.clientWidth;
                    const minLeft = 300;
                    const minRight = 200;

                    let leftWidth = e.clientX;

                    if (leftWidth < minLeft) leftWidth = minLeft;
                    if (totalWidth - leftWidth - separator.offsetWidth < minRight)
                        leftWidth = totalWidth - minRight - separator.offsetWidth;

                    stageWrap.style.flex = `0 0 ${leftWidth}px`;
                    metadataPanel.style.width = `${totalWidth - leftWidth - separator.offsetWidth}px`;
                });

                document.addEventListener('mouseup', () => { isResizing = false; });
            }

            // Seg control
            $seg.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') return;
                metaMode = e.target.dataset.mode;
                for (const b of $seg.querySelectorAll('button')) b.classList.toggle('active', b === e.target);
                const sel = gNodes.selectAll('g.node.selected').datum();
                if (sel) showDetails(sel);
            });

            document.getElementById('expandAll').addEventListener('click', () => toggleAll(true));
            document.getElementById('collapseAll').addEventListener('click', () => toggleAll(false));

            function toggleAll(open) {
                $meta.querySelectorAll('details.meta').forEach(d => d.open = open);
            }

            document.getElementById('auto').addEventListener('click', runAutoLayout);
            document.getElementById('dagreBtn').addEventListener('click', () => {
                dagreLayout(nodes, links, 'LR');
                ticked();
                saveLayout();
            });
            document.getElementById('reset').addEventListener('click', () => {
                localStorage.removeItem(layoutKey());
                nodes.forEach(n => { delete n.fx; delete n.fy; });
                runAutoLayout(true);
            });
            document.getElementById('dragMode').addEventListener('change', (e) => enableDrag(e.target.checked));
            document.getElementById('snapGrid').addEventListener('change', () => { });
            document.getElementById('showGrid').addEventListener('change', (e) => {
                $grid.style.display = e.target.checked ? 'block' : 'none';
            });

            $openFileBtn.addEventListener('click', () => {
                openMaiMLUploadModal();
            });

            function openMaiMLUploadModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay show';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Upload MaiML File</h3>
                            <button class="modal-close">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="upload-area" id="maimlUploadArea">
                                <div style="font-size:48px; margin-bottom:1rem;">üìÇ</div>
                                <p>Drag & drop MaiML files (.maiml or .maiml.zip)<br />or<br />click to select</p>
                                <input accept=".xml,.maiml,.mai,.zip,application/xml,application/zip" id="maimlFileInput" style="display:none;" type="file" />
                            </div>
                            <div id="zipProgress" style="display:none; margin-top:1rem; padding:0.8rem; background:var(--bg); border-radius:6px;">
                                <div style="font-size:12px; color:var(--muted); margin-bottom:0.5rem;">Processing ZIP archive...</div>
                                <div style="background:var(--border); height:4px; border-radius:2px; overflow:hidden;">
                                <div id="zipProgressBar" style="background:var(--accent); height:100%; width:0%; transition:width 0.3s;"></div>
                            </div>
                        </div>
                            <div style="display:flex; gap:.5rem; justify-content:flex-end; margin-top:1rem;">
                                <button class="btn" id="maimlCancelBtn">Cancel</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                const uploadArea = modal.querySelector('#maimlUploadArea');
                const fileInput = modal.querySelector('#maimlFileInput');
                const closeBtn = modal.querySelector('.modal-close');
                const cancelBtn = modal.querySelector('#maimlCancelBtn');

                uploadArea.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', async (e) => {
                    if (e.target.files[0]) {
                        await handleMaiMLFile(e.target.files[0]);
                        document.body.removeChild(modal);
                    }
                });

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files[0]) {
                        await handleMaiMLFile(e.dataTransfer.files[0]);
                        document.body.removeChild(modal);
                    }
                });

                closeBtn.addEventListener('click', () => document.body.removeChild(modal));
                cancelBtn.addEventListener('click', () => document.body.removeChild(modal));
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) document.body.removeChild(modal);
                });
            }

            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Åó„Å¶ËøΩÂä†
            let zipFileCache = new Map(); // ZIP„Åã„ÇâÂ±ïÈñã„Åó„Åü„Éï„Ç°„Ç§„É´„Çí„Ç≠„É£„ÉÉ„Ç∑„É•

            async function handleMaiMLFile(file) {
                const fileName = file.name.toLowerCase();

                // ZIP„Éï„Ç°„Ç§„É´„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
                if (fileName.endsWith('.zip') || fileName.endsWith('.maiml.zip')) {
                    await handleMaiMLZipFile(file);
                } else {
                    // ÂçòÁã¨„ÅÆMaiML„Éï„Ç°„Ç§„É´
                    netKey = file.name.replace(/\.[^.]+$/, '');
                    document.title = `${file.name}`;
                    const text = await file.text();
                    loadXml(text);
                    extractDocumentMetadata(text);
                }
            }

            async function handleMaiMLZipFile(file) {
                const modal = document.querySelector('.modal-overlay.show');
                const progressDiv = modal?.querySelector('#zipProgress');
                const progressBar = modal?.querySelector('#zipProgressBar');

                try {
                    if (progressDiv) {
                        progressDiv.style.display = 'block';
                        progressBar.style.width = '10%';
                    }

                    console.log('Loading ZIP file:', file.name);

                    // JSZip„ÅßZIP„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
                    if (typeof JSZip === 'undefined') {
                        throw new Error('JSZip library is not loaded. Please check the script tag.');
                    }

                    const zip = await JSZip.loadAsync(file);
                    console.log('ZIP loaded, files:', Object.keys(zip.files).length);

                    if (progressBar) progressBar.style.width = '30%';

                    // MaiML„Éï„Ç°„Ç§„É´„ÇíÊé¢„Åô
                    let maimlFile = null;
                    let maimlFileName = '';

                    for (const [filename, zipEntry] of Object.entries(zip.files)) {
                        if (!zipEntry.dir && (filename.endsWith('.maiml') || filename.endsWith('.xml') || filename.endsWith('.mai'))) {
                            maimlFile = zipEntry;
                            maimlFileName = filename;
                            break;
                        }
                    }

                    if (!maimlFile) {
                        throw new Error('No MaiML file (.maiml, .xml, .mai) found in ZIP archive');
                    }

                    console.log('Found MaiML file:', maimlFileName);

                    if (progressBar) progressBar.style.width = '50%';

                    // MaiML„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„ÇíË™≠„ÅøËæº„Åø
                    const maimlText = await maimlFile.async('text');

                    // „Éï„Ç°„Ç§„É´Âêç„Åã„ÇânetKey„ÇíË®≠ÂÆö
                    netKey = maimlFileName.replace(/\.[^.]+$/, '');
                    document.title = maimlFileName;

                    if (progressBar) progressBar.style.width = '60%';

                    // ZIPÂÜÖ„ÅÆÂÖ®„Éï„Ç°„Ç§„É´„Çí„Ç≠„É£„ÉÉ„Ç∑„É•„Å´Ê†ºÁ¥ç
                    zipFileCache.clear();
                    const totalFiles = Object.keys(zip.files).length;
                    let processedFiles = 0;

                    for (const [filename, zipEntry] of Object.entries(zip.files)) {
                        if (!zipEntry.dir && filename !== maimlFileName) {
                            try {
                                // „Éï„Ç°„Ç§„É´Êã°ÂºµÂ≠ê„ÅßÂá¶ÁêÜ„ÇíÂàÜÂ≤ê
                                const ext = filename.toLowerCase().split('.').pop();
                                const imageExts = ['jpg', 'jpeg', 'png', 'bmp', 'tif', 'tiff', 'gif'];
                                const textExts = ['txt', 'csv', 'json', 'xml', 'log', 'md'];

                                let fileData;
                                if (imageExts.includes(ext)) {
                                    // ÁîªÂÉè„Éï„Ç°„Ç§„É´„ÅØArrayBuffer„Å®„Åó„Å¶Ë™≠„ÅøËæº„Åø
                                    fileData = await zipEntry.async('arraybuffer');
                                } else {
                                    // „ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„ÅØ„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶Ë™≠„ÅøËæº„Åø
                                    fileData = await zipEntry.async('text');
                                }

                                // „Éï„Ç°„Ç§„É´Âêç„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„ÇíÁôªÈå≤
                                const cacheEntry = { data: fileData, ext: ext, originalName: filename };

                                console.log('--- Caching file:', filename, '---');

                                // 1. ÂÖÉ„ÅÆ„Éï„Ç°„Ç§„É´Âêç
                                zipFileCache.set(filename, cacheEntry);
                                console.log('  Cached as:', filename);

                                // 2. „Éá„Ç≥„Éº„Éâ„Åó„Åü„Éï„Ç°„Ç§„É´Âêç
                                try {
                                    const decodedName = decodeURIComponent(filename);
                                    if (filename !== decodedName) {
                                        zipFileCache.set(decodedName, cacheEntry);
                                        console.log('  Cached as (decoded):', decodedName);
                                    }
                                } catch (e) {
                                    console.warn('  Failed to decode:', e);
                                }

                                // 3. „Éë„ÇπÂå∫Âàá„ÇäÊñáÂ≠ó„ÇíÊ≠£Ë¶èÂåñ
                                const normalizedName = filename.replace(/\\/g, '/');
                                if (normalizedName !== filename) {
                                    zipFileCache.set(normalizedName, cacheEntry);
                                    console.log('  Cached as (normalized):', normalizedName);
                                }

                                // 4. „Éï„Ç°„Ç§„É´Âêç„ÅÆ„ÅøÔºà„Éë„Çπ„Å™„ÅóÔºâ
                                const baseFileName = filename.split('/').pop().split('\\').pop();
                                zipFileCache.set(baseFileName, cacheEntry);
                                console.log('  Cached as (basename):', baseFileName);

                                // 5. Â∞èÊñáÂ≠óÁâà
                                zipFileCache.set(filename.toLowerCase(), cacheEntry);
                                zipFileCache.set(baseFileName.toLowerCase(), cacheEntry);
                                console.log('  Cached as (lowercase):', baseFileName.toLowerCase());

                                console.log('Cached file:', filename, 'Size:',
                                    typeof fileData === 'string' ? fileData.length : fileData.byteLength, 'bytes');
                            } catch (err) {
                                console.warn('Failed to cache file:', filename, err);
                            }
                        }

                        processedFiles++;
                        if (progressBar) {
                            progressBar.style.width = `${60 + (processedFiles / totalFiles) * 20}%`;
                        }
                    }

                    console.log('Total cached files:', zipFileCache.size);

                    if (progressBar) progressBar.style.width = '85%';

                    // MaiML„Éï„Ç°„Ç§„É´„Çí„Éë„Éº„Çπ
                    loadXml(maimlText);
                    extractDocumentMetadata(maimlText);

                    if (progressBar) progressBar.style.width = '95%';

                    // insertion„Éï„Ç°„Ç§„É´„ÇíËá™Âãï„Éû„ÉÉ„ÉÅ„É≥„Ç∞
                    let matchCount = 0;
                    try {
                        matchCount = await autoMatchInsertionFiles();
                    } catch (autoMatchError) {
                        console.error('Auto-match error:', autoMatchError);
                        // „Ç®„É©„Éº„ÅåÂá∫„Å¶„ÇÇZIPË™≠„ÅøËæº„ÅøËá™‰Ωì„ÅØÊàêÂäü„Å®„Åó„Å¶Êâ±„ÅÜ
                    }

                    if (progressBar) progressBar.style.width = '100%';

                    console.log('ZIP processing complete');

                    // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
                    if (progressDiv) {
                        setTimeout(() => {
                            progressDiv.innerHTML = `
                    <div style="color:var(--accent2); font-weight:600; text-align:center;">
                        ‚úÖ Successfully loaded ${Object.keys(zip.files).length} files from ZIP
                        <br><span style="font-size:11px; font-weight:normal;">Auto-matched ${matchCount} insertion file(s)</span>
                    </div>
                `;
                        }, 300);

                        setTimeout(() => {
                            if (modal && modal.parentElement) {
                                document.body.removeChild(modal);
                            }
                        }, 1500);
                    }

                } catch (error) {
                    console.error('ZIP processing error:', error);

                    // „Ç®„É©„Éº„Åß„ÇÇ„Éï„Ç°„Ç§„É´„Åå„Éû„ÉÉ„ÉÅ„Åó„Å¶„ÅÑ„Çå„Å∞ÈÉ®ÂàÜÁöÑÊàêÂäü„Å®„Åó„Å¶Êâ±„ÅÜ
                    const matchedCount = insertionFiles.size;
                    if (matchedCount > 0) {
                        console.log('Despite error, successfully matched', matchedCount, 'insertion files');
                        if (progressDiv) {
                            progressDiv.innerHTML = `
                    <div style="color:var(--accent2); font-weight:600; text-align:center;">
                        ‚ö†Ô∏è Loaded with warnings
                        <br><span style="font-size:11px; font-weight:normal;">Auto-matched ${matchedCount} insertion file(s)</span>
                    </div>
                `;
                            setTimeout(() => {
                                if (modal && modal.parentElement) {
                                    document.body.removeChild(modal);
                                }
                            }, 2000);
                            return; // alert„ÇíÂá∫„Åï„Å™„ÅÑ
                        }
                    }

                    if (progressDiv) {
                        progressDiv.innerHTML = `
                <div style="color:var(--warn); font-weight:600;">
                    ‚ùå Error: ${error.message}
                </div>
            `;
                    }
                    alert('Failed to process ZIP file:\n' + error.message);
                }
            }

            async function autoMatchInsertionFiles() {
                console.log('=== Starting auto-match for insertion files ===');
                console.log('Available cached files:', Array.from(zipFileCache.keys()));
                console.log('Current insertionFiles Map size:', insertionFiles.size);

                let matchCount = 0;

                // „Åæ„Åö„ÄÅparseMaiMLÂÜÖ„Åß‰ΩúÊàê„Åï„Çå„Åüinsertion„Éá„Éº„Çø„ÇíÁ¢∫Ë™ç
                console.log('Checking global instances array...');
                const allInsertions = [];

                // instances„Å®templates„ÅÆ‰∏°Êñπ„Åã„Çâinsertion„ÇíÂèéÈõÜ
                if (window.instances) {
                    window.instances.forEach(inst => {
                        if (inst.insertions && inst.insertions.length > 0) {
                            inst.insertions.forEach(ins => {
                                allInsertions.push({
                                    id: ins.id,
                                    raw: ins.raw,
                                    element: ins.element,
                                    parentType: 'instance',
                                    parentId: inst.id
                                });
                            });
                        }
                    });
                }

                if (window.templateById) {
                    window.templateById.forEach(tpl => {
                        if (tpl.insertions && tpl.insertions.length > 0) {
                            tpl.insertions.forEach(ins => {
                                allInsertions.push({
                                    id: ins.id,
                                    raw: ins.raw,
                                    element: ins.element,
                                    parentType: 'template',
                                    parentId: tpl.id
                                });
                            });
                        }
                    });
                }

                console.log('Total insertions found:', allInsertions.length);

                if (allInsertions.length === 0) {
                    console.warn('No insertions found in parsed data');
                    return;
                }

                // ÂêÑinsertion„Å´ÂØæ„Åó„Å¶Âá¶ÁêÜ
                for (const insertion of allInsertions) {
                    console.log('---');
                    console.log('Processing insertion:', insertion.id);
                    console.log('Parent:', insertion.parentType, insertion.parentId);

                    // „Åô„Åß„Å´„Éï„Ç°„Ç§„É´„ÅåÁôªÈå≤Ê∏à„Åø„Å™„Çâ„Çπ„Ç≠„ÉÉ„Éó
                    if (insertionFiles.has(insertion.id)) {
                        console.log('‚Üí Already has file, skipping');
                        continue;
                    }

                    // XML„Åã„ÇâURI„ÇíÊäΩÂá∫
                    let uri = null;

                    // ÊñπÊ≥ï1: element „Åã„ÇâÁõ¥Êé•ÂèñÂæó
                    if (insertion.element) {
                        const uriElement = insertion.element.getElementsByTagName('uri')[0] ||
                            insertion.element.querySelector('[uri]') ||
                            Array.from(insertion.element.children || []).find(c =>
                                c.tagName.toLowerCase().includes('uri') ||
                                c.localName === 'uri'
                            );

                        if (uriElement) {
                            uri = uriElement.textContent || uriElement.getAttribute('uri') || uriElement.getAttribute('value');
                        }
                    }

                    // ÊñπÊ≥ï2: raw HTMLÊñáÂ≠óÂàó„Åã„ÇâÊ≠£Ë¶èË°®Áèæ„ÅßÊäΩÂá∫
                    if (!uri && insertion.raw) {
                        const uriMatch = insertion.raw.match(/<uri[^>]*>(.*?)<\/uri>/is) ||
                            insertion.raw.match(/uri\s*=\s*["']([^"']+)["']/i);
                        if (uriMatch) {
                            uri = uriMatch[1];
                        }
                    }

                    if (!uri) {
                        console.log('‚Üí No URI found');
                        continue;
                    }

                    uri = uri.trim();
                    console.log('Found URI:', uri);
                    console.log('Found URI (raw bytes):', Array.from(uri).map(c => c.charCodeAt(0).toString(16)).join(' '));

                    // URI„Éá„Ç≥„Éº„Éâ„Å®Ê≠£Ë¶èÂåñ
                    let decodedUri = uri;
                    try {
                        decodedUri = decodeURIComponent(uri);
                        console.log('Decoded URI:', decodedUri);
                    } catch (e) {
                        console.warn('Failed to decode URI:', e);
                    }

                    // Áõ∏ÂØæ„Éë„Çπ„ÅÆË®òÂè∑„ÇíÂâäÈô§ (./ „ÇÑ ../ „Å™„Å©)
                    const uriWithoutRelative = uri.replace(/^\.+\//g, '');
                    const decodedUriWithoutRelative = decodedUri.replace(/^\.+\//g, '');

                    console.log('URI without ./:', uriWithoutRelative);
                    console.log('Decoded URI without ./:', decodedUriWithoutRelative);

                    // „Éë„ÇπÂå∫Âàá„ÇäÊñáÂ≠ó„ÇíÊ≠£Ë¶èÂåñ
                    decodedUri = decodedUri.replace(/\\/g, '/');
                    uri = uri.replace(/\\/g, '/');

                    // „Éï„Ç°„Ç§„É´Âêç„ÅÆ„ÅøÊäΩÂá∫
                    const fileName = decodedUri.split('/').pop();
                    const fileNameEncoded = uri.split('/').pop();
                    const fileNameWithoutRelative = decodedUriWithoutRelative.split('/').pop();

                    console.log('Decoded URI (normalized):', decodedUri);
                    console.log('File name (decoded):', fileName);
                    console.log('File name (encoded):', fileNameEncoded);
                    console.log('File name (without relative path):', fileNameWithoutRelative);

                    // ZIPÂÜÖ„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÇíÂÖ®„Å¶Ë°®Á§∫Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
                    console.log('--- Checking against cached files ---');
                    console.log('Available files in cache:');
                    Array.from(zipFileCache.keys()).forEach(key => {
                        console.log('  - "' + key + '"');
                    });

                    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÊ§úÁ¥¢(Ë§áÊï∞„Éë„Çø„Éº„É≥„ÅßË©¶Ë°å)
                    let cachedFile = null;
                    let matchedKey = null;

                    const searchPatterns = [
                        uri,                                    // „Éï„É´„Éë„Çπ(„Ç®„É≥„Ç≥„Éº„ÉâÊ∏à„Åø)
                        uriWithoutRelative,                     // ./ „Å™„Åó„Ç®„É≥„Ç≥„Éº„ÉâÊ∏à„Åø
                        decodedUri,                             // „Éï„É´„Éë„Çπ(„Éá„Ç≥„Éº„ÉâÊ∏à„Åø)
                        decodedUriWithoutRelative,              // ./ „Å™„Åó„Éá„Ç≥„Éº„ÉâÊ∏à„Åø
                        fileName,                               // „Éï„Ç°„Ç§„É´Âêç„ÅÆ„Åø(„Éá„Ç≥„Éº„ÉâÊ∏à„Åø)
                        fileNameEncoded,                        // „Éï„Ç°„Ç§„É´Âêç„ÅÆ„Åø(„Ç®„É≥„Ç≥„Éº„ÉâÊ∏à„Åø)
                        fileNameWithoutRelative,                // „Éï„Ç°„Ç§„É´Âêç(Áõ∏ÂØæ„Éë„Çπ„Å™„Åó)
                        fileName.toLowerCase(),                 // Â∞èÊñáÂ≠ó
                        fileNameEncoded.toLowerCase(),
                        // Êã°ÂºµÂ≠ê„ÅÆÂ§ßÊñáÂ≠óÂ∞èÊñáÂ≠ó„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥
                        fileName.replace(/\.[^.]+$/, m => m.toLowerCase()),
                        fileName.replace(/\.[^.]+$/, m => m.toUpperCase()),
                        // „Ç®„É≥„Ç≥„Éº„ÉâÊ∏à„Åø„Éï„Ç°„Ç§„É´Âêç„ÅÆ„Éá„Ç≥„Éº„ÉâÁâà
                        decodeURIComponent(fileNameEncoded),
                        decodeURIComponent(fileNameEncoded.replace(/^\.+\//g, ''))
                    ];

                    console.log('Search patterns:', searchPatterns);

                    // ÂÆåÂÖ®‰∏ÄËá¥„ÇíË©¶„Åô
                    for (const pattern of searchPatterns) {
                        console.log('Trying exact match for pattern:', pattern);
                        if (zipFileCache.has(pattern)) {
                            cachedFile = zipFileCache.get(pattern);
                            matchedKey = pattern;
                            console.log('‚úì Exact match found:', pattern);
                            break;
                        }
                    }

                    // ÈÉ®ÂàÜ‰∏ÄËá¥„ÇíË©¶„Åô
                    if (!cachedFile) {
                        console.log('No exact match, trying partial match...');
                        for (const pattern of searchPatterns) {
                            for (const [cachedName, cachedData] of zipFileCache.entries()) {
                                const cachedLower = cachedName.toLowerCase();
                                const patternLower = pattern.toLowerCase();

                                // „Éï„Ç°„Ç§„É´ÂêçÈÉ®ÂàÜ„Å†„Åë„ÇíÂèñ„ÇäÂá∫„Åó„Å¶ÊØîËºÉ
                                const cachedFileName = cachedName.split('/').pop().split('\\').pop();
                                const cachedFileNameLower = cachedFileName.toLowerCase();

                                if (cachedName.endsWith(pattern) ||
                                    cachedLower.endsWith(patternLower) ||
                                    cachedName === pattern ||
                                    cachedLower === patternLower ||
                                    cachedFileName === pattern ||
                                    cachedFileNameLower === patternLower) {
                                    cachedFile = cachedData;
                                    matchedKey = cachedName;
                                    console.log('‚úì Partial match found:', cachedName, 'for pattern:', pattern);
                                    break;
                                }
                            }
                            if (cachedFile) break;
                        }
                    }

                    if (!cachedFile) {
                        console.warn('‚úó File not found in cache for URI:', uri);
                        console.log('Available files in cache:', Array.from(zipFileCache.keys()));
                        continue;
                    }

                    console.log('Matched file:', matchedKey);

                    // „Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÇíÂà§ÂÆö
                    const ext = cachedFile.ext;
                    const imageExts = ['jpg', 'jpeg', 'png', 'bmp', 'tif', 'tiff', 'gif'];
                    const textExts = ['txt', 'log', 'md', 'xml', 'json'];  // XML„Å®JSON„Çí„ÉÜ„Ç≠„Çπ„ÉàÂΩ¢Âºè„Å´ËøΩÂä†
                    const csvExts = ['csv'];

                    let format = 'text'; // „Éá„Éï„Ç©„É´„Éà
                    if (imageExts.includes(ext)) {
                        format = 'image';
                    } else if (csvExts.includes(ext)) {
                        format = 'table';
                    } else if (textExts.includes(ext)) {
                        format = 'text';  // XML„ÄÅJSON„ÄÅTXTÁ≠â„ÅØ„ÉÜ„Ç≠„Çπ„ÉàÂΩ¢Âºè„Å®„Åó„Å¶Êâ±„ÅÜ
                    }

                    console.log('Determined format:', format, 'for extension:', ext);

                    try {
                        // File„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åæ„Åü„ÅØ‰∫íÊèõ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
                        if (format === 'image') {
                            // ÁîªÂÉè„ÅÆÂ†¥Âêà
                            if (ext === 'tif' || ext === 'tiff') {
                                // TIFF„ÅØArrayBuffer„ÅÆ„Åæ„Åæ
                                insertionFiles.set(insertion.id, {
                                    file: { name: fileName, type: 'image/tiff' },
                                    fileData: { type: 'tiff', data: cachedFile.data, name: fileName },
                                    format: format,
                                    preview: '<p>TIFF image loaded from ZIP</p>'
                                });
                            } else {
                                // ‰ªñ„ÅÆÁîªÂÉèÂΩ¢Âºè„ÅØBlob/URL„Å´Â§âÊèõ
                                const blob = new Blob([cachedFile.data], {
                                    type: `image/${ext === 'jpg' ? 'jpeg' : ext}`
                                });
                                const url = URL.createObjectURL(blob);

                                insertionFiles.set(insertion.id, {
                                    file: { name: fileName, type: blob.type },
                                    fileData: { type: 'image', data: url, name: fileName },
                                    format: format,
                                    preview: `<img src="${url}" style="max-width:100%; height:auto;" />`
                                });
                            }
                        } else {
                            // „ÉÜ„Ç≠„Çπ„ÉàÁ≥ª„Éï„Ç°„Ç§„É´ÔºàXML„ÄÅJSON„ÄÅTXTÁ≠âÔºâ
                            // MIME„Çø„Ç§„Éó„ÇíÊã°ÂºµÂ≠ê„Å´Âøú„Åò„Å¶Ë®≠ÂÆö
                            let mimeType = 'text/plain';
                            if (ext === 'xml') {
                                mimeType = 'application/xml';
                            } else if (ext === 'json') {
                                mimeType = 'application/json';
                            } else if (ext === 'csv') {
                                mimeType = 'text/csv';
                            }

                            const fileObj = new File([cachedFile.data], fileName, {
                                type: mimeType
                            });

                            insertionFiles.set(insertion.id, {
                                file: fileObj,
                                fileData: { type: 'file', data: fileObj, name: fileName },
                                format: format,
                                preview: `<pre style="white-space:pre-wrap; max-height:200px; overflow:auto;">${String(cachedFile.data).substring(0, 500)
                                    }${String(cachedFile.data).length > 500 ? '...' : ''}</pre>`
                            });
                        }

                        matchCount++;
                        console.log('‚úì Successfully registered file for insertion:', insertion.id);

                    } catch (err) {
                        console.error('‚úó Failed to register file for insertion:', insertion.id, err);
                    }
                }

                console.log('=== Auto-match complete: ' + matchCount + ' file(s) matched ===');
                console.log('insertionFiles Map size after matching:', insertionFiles.size);
                console.log('insertionFiles keys:', Array.from(insertionFiles.keys()));

                // UIÊõ¥Êñ∞: „Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
                if (matchCount > 0) {
                    console.log('Updating UI buttons...');
                    document.querySelectorAll('[data-insertion-id]').forEach(btn => {
                        const insertionId = btn.dataset.insertionId;
                        if (insertionFiles.has(insertionId)) {
                            btn.classList.add('has-file');
                            btn.textContent = 'üîé Show File';
                            console.log('Updated button for:', insertionId);
                        }
                    });

                    // Ë©≥Á¥∞„Éë„Éç„É´„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂÜçÊèèÁîª
                    try {
                        const selectedNodes = gNodes.selectAll('g.node.selected');
                        if (selectedNodes && !selectedNodes.empty()) {
                            const selectedNode = selectedNodes.datum();
                            if (selectedNode) {
                                console.log('Refreshing details panel for selected node:', selectedNode.id);
                                showDetails(selectedNode);
                            }
                        }
                    } catch (err) {
                        console.log('Could not refresh details panel (no node selected):', err.message);
                    }
                }
                return matchCount; // ‚Üê „Åì„ÅÆË°å„ÇíËøΩÂä†
            }

            function extractDocumentMetadata(xmlText) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "application/xml");

                const documentElement = xmlDoc.getElementsByTagNameNS("http://www.maiml.org/schemas", "document")[0];
                if (!documentElement) {
                    $documentInfo.innerHTML = '<h3>üìÑ Document Metadata</h3><div class="empty-state">No Document Metadata found</div>';
                    return;
                }

                let html = '<h3>üìÑ Document Metadata</h3><table>';
                let rowCount = 0;

                const uuidEl = documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", "uuid")[0];
                const nameEl = documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", "name")[0];
                const descriptionEl = documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", "description")[0];
                const annotationEl = documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", "annotation")[0];

                if (uuidEl) {
                    html += `<tr><th>UUID</th><td colspan="2">${esc(uuidEl.textContent)}</td></tr>`;
                    rowCount++;
                }
                if (nameEl) {
                    html += `<tr><th>Name</th><td colspan="2">${esc(nameEl.textContent)}</td></tr>`;
                    rowCount++;
                }
                if (descriptionEl) {
                    html += `<tr><th>Description</th><td colspan="2">${esc(descriptionEl.textContent)}</td></tr>`;
                    rowCount++;
                }
                if (annotationEl) {
                    html += `<tr><th>Annotation</th><td colspan="2">${esc(annotationEl.textContent)}</td></tr>`;
                    rowCount++;
                }

                if (rowCount > 0) html += '<tr><th>Element</th><th>Name</th><th>Description</th></tr>';

                const tags = ["creator", "owner", "vendor", "instrument"];

                tags.forEach(tag => {
                    const elements = documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", tag);
                    for (let el of elements) {
                        const nameEl = el.getElementsByTagNameNS("http://www.maiml.org/schemas", "name")[0];
                        const descEl = el.getElementsByTagNameNS("http://www.maiml.org/schemas", "description")[0];
                        const name = nameEl ? nameEl.textContent : "";
                        const desc = descEl ? descEl.textContent : "";
                        html += `<tr><td>${esc(tag)}</td><td>${esc(name)}</td><td>${esc(desc)}</td></tr>`;
                        rowCount++;
                    }
                });
                html += "</table>";

                // <property>Ë¶ÅÁ¥†„ÅÆÊäΩÂá∫„Å®Ë°®Á§∫ÔºàÈöéÂ±§ÊßãÈÄ†ÂØæÂøúÔºâ
                const propertyElements = Array.from(documentElement.getElementsByTagNameNS("http://www.maiml.org/schemas", "property"));

                // documentË¶ÅÁ¥†„ÅÆÁõ¥Êé•„ÅÆÂ≠êË¶ÅÁ¥†„Åß„ÅÇ„Çãproperty„ÅÆ„Åø„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
                const directProperties = propertyElements.filter(prop => prop.parentNode === documentElement);

                // ÂÜçÂ∏∞ÁöÑ„Å´propertyË¶ÅÁ¥†„ÇíËß£Êûê„Åô„ÇãÈñ¢Êï∞
                function parsePropertyRecursive(propEl, level = 0) {
                    const key = propEl.getAttribute('key') || '';
                    const type = propEl.getAttribute('xsi:type') || propEl.getAttributeNS('http://www.w3.org/2001/XMLSchema-instance', 'type') || '';

                    // Áõ¥Êé•„ÅÆÂ≠êË¶ÅÁ¥†„ÅÆ„Åø„ÇíÂèñÂæó
                    const directChildren = Array.from(propEl.children || []);
                    const descEl = directChildren.find(e => e.localName === 'description' || e.tagName.includes('description'));
                    const valueEl = directChildren.find(e => e.localName === 'value' || e.tagName.includes('value'));
                    const childProperties = directChildren.filter(e => e.localName === 'property' || e.tagName.includes('property'));

                    const description = descEl ? descEl.textContent.trim() : '';
                    const value = valueEl ? valueEl.textContent.trim() : '';

                    return {
                        key,
                        type,
                        description,
                        value,
                        level,
                        children: childProperties.map(child => parsePropertyRecursive(child, level + 1))
                    };
                }

                // „Éó„É≠„Éë„ÉÜ„Ç£„ÇíÈöéÂ±§ÁöÑ„Å´Ë°®Á§∫„Åô„ÇãÈñ¢Êï∞
                function renderPropertyRows(propData) {
                    let rows = '';
                    const indent = '„ÄÄ'.repeat(propData.level); // ÂÖ®Ëßí„Çπ„Éö„Éº„Çπ„Åß„Ç§„É≥„Éá„É≥„Éà

                    rows += `<tr>
        <td>${esc(indent + propData.key)}</td>
        <td>${esc(propData.type)}</td>
        <td>${esc(propData.description)}</td>
        <td><div class="value-cell-scroll">${esc(propData.value)}</div></td>
    </tr>`;

                    // Â≠êË¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Ë°®Á§∫
                    propData.children.forEach(child => {
                        rows += renderPropertyRows(child);
                    });

                    return rows;
                }

                if (directProperties.length > 0) {
                    html += '<h3 style="margin-top:1rem;">üìã Document Properties</h3><table>';
                    html += '<tr><th>Key</th><th>Type</th><th>Description</th><th>Value</th></tr>';

                    directProperties.forEach(prop => {
                        const propData = parsePropertyRecursive(prop, 0);
                        html += renderPropertyRows(propData);
                    });

                    html += '</table>';
                }

                if (rowCount === 0 && directProperties.length === 0) {
                    $documentInfo.innerHTML = '<h3>üìÑ Document Metadata</h3><div class="empty-state">No metadata found</div>';
                } else {
                    $documentInfo.innerHTML = html;
                }
            }

            function openUploadModal(insertionId) {
                currentInsertionId = insertionId;
                currentFile = null;
                selectedFormat = null;

                $formatSelector.style.display = 'none';
                $previewArea.style.display = 'none';
                $applyBtn.style.display = 'none';

                if (insertionFiles.has(insertionId)) {
                    const stored = insertionFiles.get(insertionId);
                    currentFile = stored.file;
                    selectedFormat = stored.format;
                    showFormatSelector();
                    selectFormat(selectedFormat);
                }

                $modal.classList.add('show');
            }

            function closeModal() {
                $modal.classList.remove('show');
                currentInsertionId = null;
                currentFile = null;
                selectedFormat = null;
                $previewContent.innerHTML = '';
            }

            $modal.querySelector('.modal-close').addEventListener('click', closeModal);
            $cancelBtn.addEventListener('click', closeModal);
            $modal.addEventListener('click', (e) => {
                if (e.target === $modal) closeModal();
            });

            $uploadArea.addEventListener('click', () => $insertionFile.click());
            $insertionFile.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFile(e.target.files[0]);
            });

            $uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                $uploadArea.classList.add('dragover');
            });
            $uploadArea.addEventListener('dragleave', () => {
                $uploadArea.classList.remove('dragover');
            });
            $uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                $uploadArea.classList.remove('dragover');
                if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            });

            function handleFile(file) {
                currentFile = file;
                showFormatSelector();
            }

            function showFormatSelector() {
                $formatSelector.style.display = 'block';

                if (currentFile) {
                    const type = currentFile.type;
                    const name = currentFile.name.toLowerCase();

                    if (type.startsWith('image/') || name.endsWith('.tif') || name.endsWith('.tiff')) {
                        selectFormat('image');
                    } else if (name.endsWith('.csv')) {
                        selectFormat('chart');
                    } else if (name.endsWith('.json')) {
                        selectFormat('table');
                    } else if (name.endsWith('.xlsx') || name.endsWith('.xls') ||
                        type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                        type === 'application/vnd.ms-excel') {
                        selectFormat('table');
                    } else {
                        selectFormat('text');
                    }
                }
            }

            document.querySelectorAll('.format-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    selectFormat(opt.dataset.format);
                });
            });

            function selectFormat(format) {
                selectedFormat = format;
                document.querySelectorAll('.format-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.format === format);
                });

                if (currentFile) {
                    renderPreview(currentFile, format);
                }
            }

            async function renderPreview(file, format) {
                $previewContent.innerHTML = '<p>Loading...</p>';
                $previewArea.style.display = 'flex';
                $applyBtn.style.display = 'inline-block';

                try {
                    switch (format) {
                        case 'image':
                            await renderImage(file);
                            break;
                        case 'chart':
                            await renderChart(file);
                            break;
                        case 'table':
                            await renderTable(file);
                            break;
                        case 'text':
                            await renderText(file);
                            break;
                    }
                } catch (err) {
                    $previewContent.innerHTML = `<p style="color:var(--warn);">Error: ${err.message}</p>`;
                }
            }

            async function renderImage(file) {
                const name = file.name.toLowerCase();

                if (name.endsWith('.tif') || name.endsWith('.tiff')) {
                    try {
                        $previewContent.innerHTML = '<p>Loading TIFF file...</p>';

                        if (typeof UTIF === 'undefined') {
                            throw new Error('UTIF library is not loaded');
                        }

                        const arrayBuffer = await file.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);

                        const ifds = UTIF.decode(uint8Array);
                        if (!ifds || ifds.length === 0) {
                            throw new Error('Failed to parse TIFF file');
                        }

                        const ifd = ifds[0];
                        UTIF.decodeImage(uint8Array, ifd);

                        const canvas = document.createElement('canvas');
                        canvas.width = ifd.width;
                        canvas.height = ifd.height;
                        const ctx = canvas.getContext('2d');

                        const rgba = UTIF.toRGBA8(ifd);
                        const imageData = new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height);
                        ctx.putImageData(imageData, 0, 0);

                        $previewContent.innerHTML = '';
                        canvas.style.maxWidth = '100%';
                        canvas.style.height = 'auto';
                        canvas.style.borderRadius = '4px';
                        $previewContent.appendChild(canvas);

                        const info = document.createElement('p');
                        info.style.marginTop = '0.5rem';
                        info.style.fontSize = '12px';
                        info.style.color = 'var(--muted)';
                        info.textContent = `Image size: ${ifd.width} √ó ${ifd.height} px | TIFF format`;
                        $previewContent.appendChild(info);

                    } catch (err) {
                        console.error('TIFF loading error:', err);
                        $previewContent.innerHTML = `
                            <div style="color:var(--warn); padding:1rem;">
                            <p style="margin:0 0 0.5rem 0;"><strong>Failed to load TIFF file</strong></p>
                            <p style="margin:0; font-size:12px;">Error: ${err.message}</p>
                            <p style="margin:0.5rem 0 0 0; font-size:12px; color:var(--muted);">
                                Please try converting to another image format (JPEG, PNG).
                            </p>
                            </div>
                        `;
                    }
                } else {
                    const url = URL.createObjectURL(file);
                    const img = new Image();

                    img.onload = () => {
                        $previewContent.innerHTML = '';
                        img.style.maxWidth = '100%';
                        img.style.height = 'auto';
                        img.style.borderRadius = '4px';
                        $previewContent.appendChild(img);

                        const info = document.createElement('p');
                        info.style.marginTop = '0.5rem';
                        info.style.fontSize = '12px';
                        info.style.color = 'var(--muted)';
                        info.textContent = `Image size: ${img.naturalWidth} √ó ${img.naturalHeight} px`;
                        $previewContent.appendChild(info);
                    };

                    img.onerror = () => {
                        $previewContent.innerHTML = `<p style="color:var(--warn);">Failed to load image</p>`;
                    };

                    img.src = url;
                }
            }

            async function renderChart(file) {
                const text = await file.text();
                const parsed = Papa.parse(text, { header: true, dynamicTyping: true });

                if (parsed.errors.length > 0) {
                    throw new Error('CSV parsing error');
                }

                const data = parsed.data.filter(row => Object.values(row).some(v => v !== null && v !== ''));
                const headers = Object.keys(data[0] || {});

                if (headers.length < 2) {
                    throw new Error('Insufficient data (at least 2 columns required)');
                }

                const canvas = document.createElement('canvas');
                $previewContent.innerHTML = '';
                $previewContent.appendChild(canvas);

                new Chart(canvas, {
                    type: 'line',
                    data: {
                        labels: data.map(row => row[headers[0]]),
                        datasets: headers.slice(1).map((header, i) => ({
                            label: header,
                            data: data.map(row => row[header]),
                            borderColor: `hsl(${i * 60}, 70%, 50%)`,
                            backgroundColor: `hsla(${i * 60}, 70%, 50%, 0.1)`,
                            tension: 0.3
                        }))
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true }
                        }
                    }
                });
            }

            async function renderTable(file) {
                const text = await file.text();
                let data;

                const name = file.name.toLowerCase();

                if (name.endsWith('.xlsx') || name.endsWith('.xls') ||
                    file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                    file.type === 'application/vnd.ms-excel') {

                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const workbook = XLSX.read(arrayBuffer, { type: 'array' });

                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];

                        data = XLSX.utils.sheet_to_json(worksheet);

                        if (data.length === 0) {
                            throw new Error('No data found in Excel file');
                        }
                    } catch (err) {
                        throw new Error(`Failed to read Excel file: ${err.message}`);
                    }

                } else if (file.name.endsWith('.json')) {
                    data = JSON.parse(text);
                    if (!Array.isArray(data)) data = [data];
                } else {
                    const parsed = Papa.parse(text, { header: true });
                    data = parsed.data.filter(row => Object.values(row).some(v => v !== null && v !== ''));
                }

                if (data.length === 0) {
                    throw new Error('Data is empty');
                }

                const headers = Object.keys(data[0]);
                let html = '<table style="width:100%; border-collapse:collapse; font-size:12px;">';
                html += '<thead><tr>';
                headers.forEach(h => html += `<th style="border:1px solid var(--border); padding:0.5rem; background:var(--table-head);">${h}</th>`);
                html += '</tr></thead><tbody>';

                data.slice(0, 100).forEach(row => {
                    html += '<tr>';
                    headers.forEach(h => html += `<td style="border:1px solid var(--border); padding:0.5rem;">${row[h] ?? ''}</td>`);
                    html += '</tr>';
                });

                html += '</tbody></table>';
                if (data.length > 100) html += `<p style="margin-top:0.5rem; color:var(--muted);">(Displaying only the first 100 rows)</p>`;

                $previewContent.innerHTML = html;
            }

            async function renderText(file) {
                const text = await file.text();
                $previewContent.innerHTML = `<pre style="white-space:pre-wrap; font-size:12px; max-height:400px; overflow:auto;">${text}</pre>`;
            }

            $applyBtn.addEventListener('click', () => {
                if (currentFile && selectedFormat && currentInsertionId) {
                    const storeFileData = async () => {
                        if (currentFile.name.toLowerCase().endsWith('.tif') || currentFile.name.toLowerCase().endsWith('.tiff')) {
                            const arrayBuffer = await currentFile.arrayBuffer();
                            return {
                                type: 'tiff',
                                data: arrayBuffer,
                                name: currentFile.name
                            };
                        } else if (currentFile.type.startsWith('image/')) {
                            return {
                                type: 'image',
                                data: URL.createObjectURL(currentFile),
                                name: currentFile.name
                            };
                        } else {
                            return {
                                type: 'file',
                                data: currentFile,
                                name: currentFile.name
                            };
                        }
                    };

                    storeFileData().then(fileData => {
                        insertionFiles.set(currentInsertionId, {
                            file: currentFile,
                            fileData: fileData,
                            format: selectedFormat,
                            preview: $previewContent.innerHTML
                        });

                        const btn = document.querySelector(`[data-insertion-id="${currentInsertionId}"]`);
                        if (btn) {
                            btn.classList.add('has-file');
                            btn.textContent = 'üîé Show File';
                        }

                        closeModal();

                        // --- „ÄêËøΩÂä†„ÄëÊâãÂãï„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊôÇ„Å´Ë©≥Á¥∞„Éë„Éç„É´„Çí„É™„Éï„É¨„ÉÉ„Ç∑„É•„Åó„Å¶„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫„Åô„Çã ---
                        const selectedNodes = gNodes.selectAll('g.node.selected');
                        if (!selectedNodes.empty()) {
                            const selectedNode = selectedNodes.datum();
                            if (selectedNode) {
                                showDetails(selectedNode);
                            }
                        }
                        // -----------------------------------------------------------------------
                    });
                }
            });

            function loadXml(text) {
                nodes = [];
                links = [];
                byId.clear();
                placeToTemplates.clear();
                templateById.clear();
                templateToInstances.clear();
                instances.length = 0;
                insertionFiles.clear();
                instructionById.clear();
                transitionToInstructions.clear();
                eventsByInstructionId.clear();

                const xml = new DOMParser().parseFromString(text, 'application/xml');
                if (xml.querySelector('parsererror')) {
                    alert('Failed to parse XML.');
                    return;
                }
                parseMaiML(xml);

                // ‰∏ã„Éë„Éç„É´„ÅÆË°®Á§∫„Çí„ÇØ„É™„Ç¢
                $meta.innerHTML = '';
                $stats.textContent = 'Loading...';

                render();
                if (!restoreLayout()) runAutoLayout(true);
                else ticked();
                updateStats();
            }

            function updateStats() {
                const pc = nodes.filter(n => n.type === 'place').length;
                const tc = nodes.filter(n => n.type === 'transition').length;
                const ac = links.length;
                const tplCount = templateById.size;
                const instCount = instances.length;
                $stats.textContent = `PLACE: ${pc} / TRANSITION: ${tc} / Templates: ${tplCount} / Instances: ${instCount} (Saved Key: ${layoutKey()})`;
            }

            function parseMaiML(xml) {
                const all = Array.from(xml.getElementsByTagName('*'));
                const attr = (el, ...names) => {
                    for (const n of names) {
                        if (el.hasAttribute(n)) return el.getAttribute(n);
                        const lo = n.toLowerCase(),
                            up = n.toUpperCase();
                        if (el.hasAttribute(lo)) return el.getAttribute(lo);
                        if (el.hasAttribute(up)) return el.getAttribute(up);
                    }
                };
                const num = v => {
                    const x = Number(v);
                    return Number.isFinite(x) ? x : undefined;
                };
                const local = el => el.tagName.split(':').pop().toLowerCase();
                const getXsiType = (el) => {
                    let v = el.getAttribute('xsi:type') || el.getAttribute('type');
                    if (!v && el.getAttributeNS) {
                        try {
                            v = el.getAttributeNS('http://www.w3.org/2001/XMLSchema-instance', 'type');
                        } catch (e) { }
                    }
                    return v ? v.split(':').pop() : '';
                };
                const findAncestor = (el, pred) => {
                    let p = el.parentElement;
                    while (p) {
                        if (pred(p)) return p;
                        p = p.parentElement;
                    }
                    return null;
                };

                for (const el of all) {
                    const l = local(el);
                    if (l === 'place') {
                        const id = attr(el, 'id', 'ID', 'Id') || genId('p');
                        const label = attr(el, 'name') || id;
                        const x = num(attr(el, 'x', 'cx')),
                            y = num(attr(el, 'y', 'cy'));
                        const r = num(attr(el, 'r', 'radius')) || 16;
                        const n = { id, type: 'place', label, r, x, y, rawEl: el };
                        nodes.push(n);
                        byId.set(id, n);
                    } else if (l === 'transition') {
                        const id = attr(el, 'id', 'ID', 'Id') || genId('t');
                        const label = attr(el, 'name') || id;
                        const x = num(attr(el, 'x')),
                            y = num(attr(el, 'y'));
                        const w = num(attr(el, 'w', 'width')) || 24,
                            h = num(attr(el, 'h', 'height')) || 50;
                        const n = { id, type: 'transition', label, w, h, x, y, rawEl: el };
                        nodes.push(n);
                        byId.set(id, n);
                    }
                }

                for (const el of all) {
                    const l = local(el);
                    if (l.endsWith('arc')) {
                        let s = attr(el, 'source');
                        let tg = attr(el, 'target');
                        if (!s && !tg) {
                            const pr = attr(el, 'place', 'placeRef', 'placeID');
                            const tr = attr(el, 'transition', 'transitionRef');
                            if (pr && tr) {
                                s = pr;
                                tg = tr;
                            }
                        }
                        if (s && tg && byId.has(s) && byId.has(tg)) links.push({ source: s, target: tg, rawEl: el });
                    }
                }

                for (const el of all) {
                    const l = local(el);
                    let role = null;
                    if (l === 'materialtemplate') role = 'material';
                    else if (l === 'conditiontemplate') role = 'condition';
                    else if (l === 'resulttemplate') role = 'result';
                    if (!role) continue;
                    const prog = findAncestor(el, a => ['program', 'transition'].includes(local(a)));
                    const programId = prog ? (prog.getAttribute('id') || prog.getAttribute('ID') || prog.getAttribute('Id')) : null;
                    const tpl = extractTemplate(el, role, programId);
                    templateById.set(tpl.id, tpl);
                    const refs = Array.from(el.getElementsByTagName('*')).filter(e => local(e) === 'placeref');
                    for (const r of refs) {
                        const refId = r.getAttribute('ref') || r.getAttribute('Ref') || r.getAttribute('REF');
                        if (refId) {
                            tpl.placeRef = tpl.placeRef || refId;
                            (placeToTemplates.get(refId) || placeToTemplates.set(refId, []).get(refId)).push(tpl);
                        }
                    }
                }

                for (const el of all) {
                    const l = local(el);
                    let role = null;
                    if (l === 'material') role = 'material';
                    else if (l === 'condition') role = 'condition';
                    else if (l === 'result') role = 'result';
                    if (!role) continue;
                    const tplRef = el.getAttribute('ref') || el.getAttribute('Ref') || el.getAttribute('REF') || el.getAttribute('templateRef') || el.getAttribute('classRef');
                    const id = el.getAttribute('id') || el.getAttribute('ID') || el.getAttribute('Id') || genId(role[0]);

                    const meta = extractMetaBlock(el);
                    const rec = {
                        id,
                        role,
                        templateRef: tplRef || null,
                        properties: meta.properties,
                        contents: meta.contents,
                        insertions: meta.insertions,
                        uuid: meta.uuid,
                        name: meta.name,
                        description: meta.description,
                        annotation: meta.annotation,
                        instanceRefs: meta.instanceRefs,
                        rawEl: el
                    };
                    instances.push(rec);
                    if (tplRef) {
                        (templateToInstances.get(tplRef) || templateToInstances.set(tplRef, []).get(tplRef)).push(rec);
                    }
                    for (const tpl of templateById.values()) {
                        if (tpl.templateRefs && tpl.templateRefs.length > 0) {
                            tpl.templateRefs.forEach(refId => {
                                const refTpl = templateById.get(refId);
                                if (refTpl && tpl.placeRef && refTpl.placeRef) {
                                    links.push({
                                        source: tpl.placeRef,
                                        target: refTpl.placeRef,
                                        type: 'templateRef',
                                        rawEl: null
                                    });
                                }
                            });
                        }
                    }

                    for (const inst of instances) {
                        if (inst.instanceRefs && inst.instanceRefs.length > 0) {
                            inst.instanceRefs.forEach(refId => {
                                const refInst = instances.find(i => i.id === refId);
                                if (refInst) {
                                    const srcTpl = templateById.get(inst.templateRef);
                                    const tgtTpl = templateById.get(refInst.templateRef);
                                    if (srcTpl && tgtTpl && srcTpl.placeRef && tgtTpl.placeRef) {
                                        links.push({
                                            source: srcTpl.placeRef,
                                            target: tgtTpl.placeRef,
                                            type: 'instanceRef',
                                            rawEl: null
                                        });
                                    }
                                }
                            });
                        }
                    }
                }

                // ... Êó¢Â≠ò„ÅÆ„É´„Éº„ÉóÂá¶ÁêÜ„ÅÆÂæå ...

                // --- „ÄêËøΩÂä†„ÄëinstructionË¶ÅÁ¥†„ÅÆËß£Êûê ---
                for (const el of all) {
                    const l = local(el);
                    if (l === 'instruction') {
                        const id = attr(el, 'id', 'ID', 'Id');
                        if (!id) continue;

                        // „Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥„Å∏„ÅÆÂèÇÁÖß„ÇíÊé¢„Åô
                        // 1. Â≠êË¶ÅÁ¥† <transitionRef ref="..."> „ÇíÊé¢„Åô (Ê®ôÊ∫ñÁöÑ)
                        let tRef = null;
                        const trRefEl = Array.from(el.getElementsByTagName('*')).find(e => local(e) === 'transitionref');
                        if (trRefEl) tRef = attr(trRefEl, 'ref', 'Ref', 'REF');

                        // 2. Â±ûÊÄß ref="..." „ÇíÊé¢„Åô („É¶„Éº„Ç∂„ÉºÊßò„ÅÆ„Ç±„Éº„Çπ)
                        if (!tRef) tRef = attr(el, 'ref', 'Ref', 'REF') || attr(el, 'transitionRef');

                        const meta = extractMetaBlock(el);
                        instructionById.set(id, {
                            id,
                            transitionRef: tRef,
                            ...meta,
                            rawEl: el
                        });

                        if (tRef) {
                            if (!transitionToInstructions.has(tRef)) transitionToInstructions.set(tRef, []);
                            transitionToInstructions.get(tRef).push(id);
                        }
                    }
                }

                // --- „ÄêËøΩÂä†„ÄëeventË¶ÅÁ¥†„ÅÆËß£Êûê ---
                for (const el of all) {
                    const l = local(el);
                    if (l === 'event') {
                        const ref = attr(el, 'ref', 'Ref', 'REF'); // instruction„ÇíÂèÇÁÖß
                        if (ref) {
                            const meta = extractMetaBlock(el);
                            if (!eventsByInstructionId.has(ref)) eventsByInstructionId.set(ref, []);
                            eventsByInstructionId.get(ref).push({ ...meta, rawEl: el });
                        }
                    }
                }
                // ---------------------------------------

                function genId(prefix) {
                    // ...
                    return prefix + '_' + Math.random().toString(36).slice(2, 8);
                }

                function extractTemplate(tEl, role, programId) {
                    const id = tEl.getAttribute('id') || tEl.getAttribute('ID') || tEl.getAttribute('Id') || genId(role[0] + 'tpl');
                    const base = extractMetaBlock(tEl);
                    return {
                        id,
                        tag: tEl.tagName,
                        role,
                        programId,
                        properties: base.properties,
                        contents: base.contents,
                        insertions: base.insertions,
                        uuid: base.uuid,
                        name: base.name,
                        description: base.description,
                        annotation: base.annotation,
                        templateRefs: base.templateRefs,
                        placeRef: null
                    };
                }

                function extractMetaBlock(root) {
                    const props = [], conts = [], insertions = [];
                    let uuid = '', name = '', description = '', annotation = '';
                    const templateRefs = [];
                    const instanceRefs = [];

                    const directChildren = Array.from(root.children || []);
                    for (const child of directChildren) {
                        const l = local(child);

                        if (l === 'uuid') uuid = child.textContent.trim();
                        else if (l === 'name') name = child.textContent.trim();
                        else if (l === 'description') description = child.textContent.trim();
                        else if (l === 'annotation') annotation = child.textContent.trim();
                        else if (l === 'templateref') {
                            const refId = child.getAttribute('ref') || child.getAttribute('Ref') || child.getAttribute('REF');
                            if (refId) templateRefs.push(refId);
                        }
                        else if (l === 'instanceref') {
                            const refId = child.getAttribute('ref') || child.getAttribute('Ref') || child.getAttribute('REF');
                            if (refId) instanceRefs.push(refId);
                        }
                    }

                    // Áõ¥Êé•„ÅÆÂ≠êË¶ÅÁ¥†„Åã„Çâproperty/content/insertion„ÇíÂèñÂæóÔºàÂÜçÂ∏∞ÁöÑ„Å´Â≠êÂ≠´„ÇíÂèñÂæó„Åó„Å™„ÅÑÔºâ
                    const directChildren2 = Array.from(root.children || []);  // ‚Üê Êñ∞„Åó„ÅÑ„Ç≥„Éº„Éâ
                    for (const e of directChildren2) {
                        const l = local(e);
                        if (l === 'property') props.push(readProperty(e));
                        else if (l === 'content') conts.push(readContent(e));
                        else if (l === 'insertion') {
                            // insertionË¶ÅÁ¥†„ÅÆID„Çí‰øùÊåÅ(„Å™„Åë„Çå„Å∞ÁîüÊàê)
                            const insId = e.getAttribute('id') || e.getAttribute('ID') || e.getAttribute('Id') || genId('ins');
                            insertions.push({
                                raw: e.outerHTML,
                                id: insId,
                                element: e  // ÂÖÉ„ÅÆXMLË¶ÅÁ¥†„ÇÇ‰øùÊåÅ
                            });
                        }
                    }

                    return { properties: props, contents: conts, insertions, uuid, name, description, annotation, templateRefs, instanceRefs };
                }

                function readProperty(el) {
                    const child = name => {
                        const c = Array.from(el.children || []).find(x => local(x) === name);
                        return c ? (c.textContent || '').trim() : '';
                    };
                    const key = el.getAttribute('key') || '';
                    const type = getXsiType(el);
                    const units = el.getAttribute('units') || '';
                    const fstring = el.getAttribute('formatString') || '';
                    const name = child('name');
                    const description = child('description') || el.getAttribute('description') || el.getAttribute('desc') || '';

                    // valueË¶ÅÁ¥†„ÇíÊåÅ„Å§Â†¥Âêà„ÅØ„Åù„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÄÅÊåÅ„Åü„Å™„ÅÑÂ†¥Âêà„ÅØÂ±ûÊÄßÂÄ§„ÄÅ„Åù„Çå„ÇÇ„Å™„Åë„Çå„Å∞Á©∫ÊñáÂ≠ó
                    const valueEl = Array.from(el.children || []).find(x => local(x) === 'value');
                    const value = valueEl ? valueEl.textContent.trim() : (el.getAttribute('value') || '');

                    // Â≠êË¶ÅÁ¥†„ÇíÂèñÂæóÔºàpropertyË¶ÅÁ¥†„Å®contentË¶ÅÁ¥†„ÅÆ‰∏°ÊñπÔºâ
                    const directChildren = Array.from(el.children || []);
                    const childProperties = directChildren.filter(e => {
                        const tagName = local(e);
                        return tagName === 'property';
                    });
                    const childContents = directChildren.filter(e => {
                        const tagName = local(e);
                        return tagName === 'content';
                    });

                    // Â≠êpropertyË¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
                    const children = childProperties.map(childEl => readProperty(childEl));

                    // Â≠êcontentË¶ÅÁ¥†„ÇÇÂá¶ÁêÜ„Åó„Å¶ËøΩÂä†
                    childContents.forEach(childEl => {
                        children.push(readContent(childEl));
                    });

                    return { kind: 'property', key, name, type, description, value, units, fstring, children };
                }

                function readContent(el) {
                    const child = name => {
                        const c = Array.from(el.children || []).find(x => local(x) === name);
                        return c ? (c.textContent || '').trim() : '';
                    };
                    const key = el.getAttribute('key') || '';
                    const type = getXsiType(el);
                    const units = el.getAttribute('units') || '';
                    const fstring = el.getAttribute('formatString') || '';
                    const name = child('name') || el.getAttribute('name') || '';
                    const description = child('description') || el.getAttribute('description') || el.getAttribute('desc') || '';

                    // valueË¶ÅÁ¥†„ÇíÊåÅ„Å§Â†¥Âêà„ÅØ„Åù„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÄÅÊåÅ„Åü„Å™„ÅÑÂ†¥Âêà„ÅØÂ±ûÊÄßÂÄ§„ÄÅ„Åù„Çå„ÇÇ„Å™„Åë„Çå„Å∞Á©∫ÊñáÂ≠ó
                    const valueEl = Array.from(el.children || []).find(x => local(x) === 'value');
                    const value = valueEl ? valueEl.textContent.trim() : (el.getAttribute('value') || '');

                    // Â≠êcontentË¶ÅÁ¥†„ÇíÂèñÂæó
                    const directChildren = Array.from(el.children || []);
                    const childContents = directChildren.filter(e => {
                        const tagName = local(e);
                        return tagName === 'content';
                    });
                    const children = childContents.map(childEl => readContent(childEl));

                    return { kind: 'content', key, name, type, description, value, units, fstring, children };
                }
            }

            let selLinks, selNodes;

            function render() {
                selLinks = gLinks.selectAll('line.link').data(links, d => {
                    const src = d.source.id || d.source;
                    const tgt = d.target.id || d.target;
                    const type = d.type || 'arc';
                    return `${src}->${tgt}-${type}`;
                });
                selLinks.exit().remove();
                selLinks = selLinks.enter()
                    .append('line')
                    .attr('class', d => d.type ? `link ref-link` : 'link')
                    .attr('marker-end', 'url(#arrow)')
                    .merge(selLinks);

                selNodes = gNodes.selectAll('g.node').data(nodes, d => d.id);
                selNodes.exit().remove();
                const enter = selNodes.enter().append('g').attr('class', d => `node ${d.type}`);

                enter.each(function (d) {
                    const s = d3.select(this);
                    if (d.type === 'place') {
                        const r = d.r || 16;
                        s.append('circle').attr('r', r);
                        s.append('text').attr('class', 'label').attr('dy', r + 12).attr('text-anchor', 'middle').text(d.label || d.id);
                    } else {
                        d.w = d.w || 24;
                        d.h = d.h || 50;
                        s.append('rect').attr('x', -d.w / 2).attr('y', -d.h / 2).attr('width', d.w).attr('height', d.h);
                        s.append('text').attr('class', 'label').attr('dy', d.h / 2 + 12).attr('text-anchor', 'middle').text(d.label || d.id);
                    }
                });

                selNodes = enter.merge(selNodes);
                selNodes.on('click', (e, d) => {
                    selNodes.classed('selected', n => n === d);
                    showDetails(d);
                });
                enableDrag(true);
            }

            function runAutoLayout(resetAlpha = false) {
                if (simulation) simulation.stop();
                const W = svg.node().clientWidth,
                    H = svg.node().clientHeight;
                nodes.forEach(n => {
                    if (!Number.isFinite(n.x) || !Number.isFinite(n.y)) {
                        n.x = W / 2 + (Math.random() - 0.5) * 200;
                        n.y = H / 2 + (Math.random() - 0.5) * 200;
                    }
                });
                const separateX = d3.forceX(d => d.type === 'place' ? W * 0.4 : W * 0.6).strength(0.08);
                const collide = d3.forceCollide().radius(d => (d.type === 'place' ? (d.r || 16) : Math.max(d.w || 28, d.h || 18) / 2) + 8);
                simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links).id(d => d.id).distance(72).strength(0.6))
                    .force('charge', d3.forceManyBody().strength(-280))
                    .force('center', d3.forceCenter(W / 2, H / 2))
                    .force('separate', separateX)
                    .force('collide', collide)
                    .alpha(resetAlpha ? 1 : 0.3)
                    .alphaDecay(0.05)
                    .on('tick', ticked)
                    .on('end', () => saveLayout());
            }

            function ticked() {
                const W = svg.node().clientWidth,
                    H = svg.node().clientHeight;
                selNodes.attr('transform', d => {
                    const m = 20,
                        hw = (d.type === 'place') ? (d.r || 16) : (d.w || 28) / 2,
                        hh = (d.type === 'place') ? (d.r || 16) : (d.h || 18) / 2;
                    d.x = Math.max(m + hw, Math.min(W - m - hw, d.x));
                    d.y = Math.max(m + hh, Math.min(H - m - hh, d.y));
                    return `translate(${d.x},${d.y})`;
                });
                selLinks.attr('x1', d => getN(d.source).x).attr('y1', d => getN(d.source).y)
                    .attr('x2', d => getN(d.target).x).attr('y2', d => getN(d.target).y);
            }

            function getN(idOrObj) {
                return (typeof idOrObj === 'object') ? idOrObj : nodes.find(n => n.id === idOrObj);
            }

            const gridSize = 10;

            function enableDrag(enabled) {
                selNodes.call(enabled ? d3.drag()
                    .on('start', (event, d) => {
                        if (simulation) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on('drag', (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                        ticked();
                    })
                    .on('end', (event, d) => {
                        if (document.getElementById('snapGrid').checked) {
                            d.fx = Math.round(d.fx / gridSize) * gridSize;
                            d.fy = Math.round(d.fy / gridSize) * gridSize;
                            d.x = d.fx;
                            d.y = d.fy;
                        }
                        if (simulation) simulation.alphaTarget(0);
                        saveLayout();
                    }) : null);
            }

            function layoutKey() {
                return 'maiml-layout:' + (netKey || 'default');
            }

            function saveLayout() {
                const pos = Object.fromEntries(nodes.map(n => [n.id, { x: n.fx ?? n.x, y: n.fy ?? n.y }]));
                localStorage.setItem(layoutKey(), JSON.stringify(pos));
            }

            function restoreLayout() {
                const raw = localStorage.getItem(layoutKey());
                if (!raw) return false;
                try {
                    const pos = JSON.parse(raw);
                    nodes.forEach(n => {
                        if (pos[n.id]) {
                            n.x = pos[n.id].x;
                            n.y = pos[n.id].y;
                            n.fx = n.x;
                            n.fy = n.y;
                        }
                    });
                    return true;
                } catch (_) {
                    return false;
                }
            }

            function dagreLayout(nodes, links, dir = 'LR') {
                if (!window.dagre) {
                    alert('dagre library is not loaded.');
                    return;
                }
                const g = new dagre.graphlib.Graph();
                g.setGraph({ rankdir: dir, nodesep: 32, ranksep: 80, marginx: 20, marginy: 20 });
                g.setDefaultEdgeLabel(() => ({}));
                nodes.forEach(n => {
                    const w = (n.type === 'place') ? (n.r || 16) * 2 : (n.w || 28);
                    const h = (n.type === 'place') ? (n.r || 16) * 2 : (n.h || 18);
                    g.setNode(n.id, { width: w, height: h, label: n.label || n.id });
                });
                links.forEach(l => g.setEdge((l.source.id || l.source), (l.target.id || l.target)));
                dagre.layout(g);
                g.nodes().forEach(id => {
                    const p = g.node(id);
                    const n = nodes.find(x => x.id === id);
                    n.x = p.x;
                    n.y = p.y;
                    n.fx = n.x;
                    n.fy = n.y;
                });
            }

            function showDetails(node) {
                $meta.innerHTML = '';
                const basic = document.createElement('table');
                basic.className = 'kv';
                basic.innerHTML = `
        <tr><th>ID</th><td>${esc(node.id)}</td></tr>
        <tr><th>Type</th><td>${esc(node.type)}</td></tr>`;
                $meta.appendChild(basic);

                if (node.type === 'place') {
                    const tpls = placeToTemplates.get(node.id) || [];
                    const insts = tpls.flatMap(t => templateToInstances.get(t.id) || []);

                    const diag = document.createElement('div');
                    diag.className = 'hint';
                    diag.textContent = `templates: ${tpls.length}, instances: ${insts.length}`;
                    $meta.appendChild(diag);

                    if (metaMode !== 'instance') {
                        const ht = document.createElement('h3');
                        ht.className = 'section-title';
                        ht.textContent = `Templates: ${tpls.length}`;
                        $meta.appendChild(ht);
                        if (!tpls.length) {
                            const p = document.createElement('p');
                            p.className = 'hint';
                            p.textContent = 'No templates referenced by placeRef found.';
                            $meta.appendChild(p);
                        }
                        tpls.forEach((tpl, i) => {
                            // renderEntryDetails„Çí‰ΩøÁî®
                            $meta.appendChild(renderEntryDetails(tpl, i + 1, 'template'));
                        });
                    }
                    if (metaMode !== 'template') {
                        const hi = document.createElement('h3');
                        hi.className = 'section-title';
                        hi.textContent = `Instances: ${insts.length}`;
                        $meta.appendChild(hi);
                        if (!insts.length) {
                            const p = document.createElement('p');
                            p.className = 'hint';
                            p.textContent = 'No instances referencing templates corresponding to this PLACE were found.';
                            $meta.appendChild(p);
                        }
                        insts.forEach((ins, i) => {
                            // renderEntryDetails„Çí‰ΩøÁî®
                            $meta.appendChild(renderEntryDetails(ins, i + 1, 'instance'));
                        });
                    }
                } else if (node.type === 'transition') {
                    // --- „Äê‰øÆÊ≠£„Äë„ÉÜ„É≥„Éó„É¨„Éº„ÉàË°®Á§∫„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂ§âÊõ¥ ---
                    const tpls = Array.from(templateById.values()).filter(t => t.programId === node.id);

                    // „ÉÜ„É≥„Éó„É¨„Éº„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø„Çª„ÇØ„Ç∑„Éß„É≥„ÇíË°®Á§∫
                    if (tpls.length > 0) {
                        const h = document.createElement('h3');
                        h.className = 'section-title';
                        h.textContent = 'Templates directly under program';
                        $meta.appendChild(h);
                        tpls.forEach((tpl, i) => $meta.appendChild(renderTemplateDetails(tpl, i + 1)));
                    }

                    // --- „ÄêËøΩÂä†„ÄëInstructions / Events „ÅÆË°®Á§∫ ---
                    const instrIds = transitionToInstructions.get(node.id) || [];

                    if (instrIds.length > 0) {
                        const h2 = document.createElement('h3');
                        h2.className = 'section-title';
                        h2.textContent = `Instructions: ${instrIds.length}`;
                        $meta.appendChild(h2);

                        instrIds.forEach((iid, idx) => {
                            const instr = instructionById.get(iid);
                            const events = eventsByInstructionId.get(iid) || [];

                            const det = document.createElement('details');
                            det.className = 'meta';
                            det.open = true;
                            const sum = document.createElement('summary');
                            sum.innerHTML = `<span class="badge">#${idx + 1}</span> [Instruction]  ${esc(instr.id)}`;
                            det.appendChild(sum);
                            // Instruction„ÅÆ„É°„Çø„Éá„Éº„ÇøË°®Á§∫
                            // UUID, Name, Description, Annotation, Reference Transition „ÇíË°®Á§∫
                            if (instr.uuid || instr.name || instr.description || instr.annotation || instr.transitionRef) {
                                const tbl = document.createElement('table');
                                tbl.className = 'kv';
                                tbl.style.marginTop = '0.5rem';
                                let html = '';

                                // UUID
                                if (instr.uuid) html += `<tr><th>UUID</th><td>${esc(instr.uuid)}</td></tr>`;
                                // Name
                                if (instr.name) html += `<tr><th>Name</th><td>${esc(instr.name)}</td></tr>`;
                                // Description
                                if (instr.description) html += `<tr><th>Description</th><td>${esc(instr.description)}</td></tr>`;
                                // Annotation
                                if (instr.annotation) html += `<tr><th>Annotation</th><td>${esc(instr.annotation)}</td></tr>`;
                                // Reference Transition („Åì„ÅÆInstruction„ÅåÂèÇÁÖß„Åó„Å¶„ÅÑ„Çã„Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥ID)
                                if (instr.transitionRef) html += `<tr><th>Ref. Transition</th><td>${esc(instr.transitionRef)}</td></tr>`;

                                tbl.innerHTML = html;
                                det.appendChild(tbl);
                            }

                            // Instruction„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£
                            if (instr.properties && instr.properties.length > 0) {
                                det.appendChild(renderPropertiesTable(instr.properties));
                            }

                            // Á¥ê„Å•„ÅèEvent„Åå„ÅÇ„Çå„Å∞Ë°®Á§∫
                            if (events.length > 0) {
                                const hEvt = document.createElement('h4');
                                hEvt.style.margin = '0.5rem 0 0.2rem';
                                hEvt.textContent = `Event Properties: ${events.length}`;
                                det.appendChild(hEvt);

                                events.forEach((evt, eIdx) => {
                                    const div = document.createElement('div');
                                    div.style.border = '1px dashed var(--border)';
                                    div.style.padding = '0.5rem';
                                    div.style.margin = '0.2rem 0';
                                    div.style.borderRadius = '4px';

                                    div.innerHTML = `<div style="font-size:12px; font-weight:bold; color:var(--accent);">Event #${eIdx + 1}</div>`;

                                    if (evt.properties && evt.properties.length > 0) {
                                        div.appendChild(renderPropertiesTable(evt.properties));
                                    } else {
                                        div.insertAdjacentHTML('beforeend', '<span class="hint">No properties</span>');
                                    }
                                    det.appendChild(div);
                                });
                            }

                            $meta.appendChild(det);
                        });
                    }

                    // „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇÇInstruction„ÇÇ„Å™„ÅÑÂ†¥Âêà
                    if (tpls.length === 0 && instrIds.length === 0) {
                        const p = document.createElement('p');
                        p.className = 'hint';
                        p.textContent = 'No templates or instructions linked to this transition.';
                        $meta.appendChild(p);
                    }
                }
            }

            /**
             * Template „Å® Instance „ÅÆË©≥Á¥∞Ë°®Á§∫„ÇíÂÖ±ÈÄö„ÅßË°å„ÅÜÈñ¢Êï∞Ôºà‰øÆÊ≠£ÁâàÔºâ
             */
            function renderEntryDetails(item, index, mode) {
                const isTemplate = mode === 'template';
                const det = document.createElement('details');
                det.className = 'meta';
                if (!isTemplate) det.open = true;

                const sum = document.createElement('summary');
                const badgeStyle = isTemplate ? '' : 'style="background:var(--accent2); color:#fff;"';
                const label = isTemplate ? 'Template' : 'Instance';
                sum.innerHTML = `<span class="badge" ${badgeStyle}>#${index}</span> [${label}] ${esc(item.id || '')} ${isTemplate ? `(${esc(item.role || '')})` : ''}`;

                // --- AIË¶ÅÁ¥Ñ„Éú„Çø„É≥„ÇíËøΩÂä† ---
                const aiBtn = document.createElement('button');
                aiBtn.textContent = 'AI Summary';
                aiBtn.className = 'btn';
                aiBtn.style.marginLeft = '8px';
                aiBtn.style.fontSize = '11px';
                aiBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // details„ÅÆÈñãÈñâ„ÇíÈò≤„Åê

                    const obj = item;
                    let parts = [];
                    ['id', 'role', 'name', 'description', 'annotation'].forEach(k => {
                        if (obj[k]) parts.push(k.toUpperCase() + ": " + obj[k]);
                    });

                    // ÈöéÂ±§ÊßãÈÄ†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ„Åô„ÇãÈñ¢Êï∞
                    function flattenProperties(items, prefix = '') {
                        const result = [];
                        items.forEach(item => {
                            const key = prefix ? `${prefix}.${item.key || item.name}` : (item.key || item.name);
                            const info = [];
                            if (item.type) info.push(`type=${item.type}`);
                            if (item.description) info.push(`desc="${item.description}"`);
                            if (item.value) info.push(`value="${item.value}"`);
                            if (item.units) info.push(`units=${item.units}`);

                            result.push(`${key}: ${info.join(', ')}`);

                            // Â≠êË¶ÅÁ¥†„Åå„ÅÇ„Çå„Å∞ÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
                            if (item.children && item.children.length > 0) {
                                result.push(...flattenProperties(item.children, key));
                            }
                        });
                        return result;
                    }

                    if (obj.properties && obj.properties.length > 0) {
                        parts.push("Properties:");
                        parts.push(...flattenProperties(obj.properties));
                    }
                    if (obj.contents && obj.contents.length > 0) {
                        parts.push("Contents:");
                        parts.push(...flattenProperties(obj.contents));
                    }
                    const text = parts.join("\n");
                    window.openAISummaryDialog ? window.openAISummaryDialog(text) : alert("AI summary feature is not initialized");
                });
                sum.appendChild(aiBtn);
                // --- AIË¶ÅÁ¥Ñ„Éú„Çø„É≥ËøΩÂä†„Åì„Åì„Åæ„Åß ---

                det.appendChild(sum);

                // --- 1. Âü∫Êú¨ÊÉÖÂ†±„ÉÜ„Éº„Éñ„É´ ---
                const infoTable = document.createElement('table');
                infoTable.className = 'kv';
                infoTable.style.marginTop = '0.5rem';

                let infoHtml = '';

                if (item.uuid) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">UUID</th><td>${esc(item.uuid)}</td></tr>`;
                if (item.name) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Name</th><td>${esc(item.name)}</td></tr>`;
                if (item.description) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Description</th><td>${esc(item.description)}</td></tr>`;
                if (item.annotation) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Annotation</th><td>${esc(item.annotation)}</td></tr>`;
                if (isTemplate && item.placeRef) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Place Ref</th><td>${esc(item.placeRef)}</td></tr>`;
                if (!isTemplate && item.templateRef) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Template Ref</th><td>${esc(item.templateRef)}</td></tr>`;
                if (!isTemplate && item.instanceOf) infoHtml += `<tr><th style="width:1%; white-space:nowrap;">Instance Of</th><td>${esc(item.instanceOf)}</td></tr>`;

                if (infoHtml) {
                    infoTable.innerHTML = infoHtml;
                    det.appendChild(infoTable);
                }

                // --- 2. Insertion „ÅÆË°®Á§∫ ---
                const insertions = item.insertions || [];
                if (insertions.length) {
                    const h = document.createElement('h4');
                    h.textContent = 'insertion';
                    det.appendChild(h);
                    insertions.forEach(x => {
                        const container = document.createElement('div');
                        container.className = 'insertion-container';

                        // A. „ÉÜ„Éº„Éñ„É´ÈÉ®ÂàÜÔºàinsertionId„ÇíÊ∏°„Åó„Å¶ÁîªÂÉè„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫ÂèØËÉΩ„Å´„Åô„ÇãÔºâ
                        const contentDiv = document.createElement('div');
                        contentDiv.innerHTML = formatInsertionAsTable(x.raw || '', x.id);
                        container.appendChild(contentDiv);

                        // B. „Éú„Çø„É≥ÈÉ®ÂàÜ (√•¬≥√•¬Ø‚Äû√£‚Ä∫√©‚Ä¶√ß¬Ω¬Æ)
                        const btnWrapper = document.createElement('div');
                        btnWrapper.style.cssText = "display:flex; justify-content:flex-end; margin-top:0.3rem;";

                        const btn = document.createElement('button');
                        btn.className = 'insertion-upload-btn';

                        // ‚òÖÈáçË¶Å: CSS „ÅÆ absolute ÈÖçÁΩÆ„ÇíÊâì„Å°Ê∂à„Åó„Å¶ static „Å´„Åô„Çã
                        btn.style.position = 'static';

                        btn.textContent = insertionFiles.has(x.id) ? 'üîé Show File' : 'üì§ Upload';
                        btn.dataset.insertionId = x.id;
                        if (insertionFiles.has(x.id)) btn.classList.add('has-file');

                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (insertionFiles.has(x.id)) showStoredFile(x.id);
                            else openUploadModal(x.id);
                        });

                        btnWrapper.appendChild(btn);
                        container.appendChild(btnWrapper);

                        det.appendChild(container);
                    });
                }

                // --- 3. Properties / Content „ÉÜ„Éº„Éñ„É´ ---
                const allProps = (item.properties || []).concat(item.contents || []);

                if (allProps.length > 0) {
                    const h = document.createElement('h4');
                    h.textContent = 'Properties / Content';
                    det.appendChild(h);
                    const propsTableElement = renderPropertiesTable(allProps);
                    det.appendChild(propsTableElement);
                } else {
                    const p = document.createElement('p');
                    p.className = 'hint';
                    p.textContent = 'No properties available.';
                    det.appendChild(p);
                }

                return det;
            }

            /**
             * Insertion XML„Çí„ÉÜ„Éº„Éñ„É´Âåñ„Åô„ÇãÈñ¢Êï∞
             * @param {string} xmlString - XMLÊñáÂ≠óÂàó
             * @param {string} insertionId - insertionË¶ÅÁ¥†„ÅÆIDÔºàÁîªÂÉè„Éó„É¨„Éì„É•„ÉºÁî®Ôºâ
             */
            function formatInsertionAsTable(xmlString, insertionId) {
                if (!xmlString) return '';
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    const root = xmlDoc.documentElement;
                    if (root.getElementsByTagName("parsererror").length > 0) return `<pre class="xml-snip">${esc(xmlString)}</pre>`;

                    // ÁîªÂÉè„Éï„Ç°„Ç§„É´„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const hasImage = insertionId && insertionFiles.has(insertionId);
                    const storedFile = hasImage ? insertionFiles.get(insertionId) : null;
                    const isImage = storedFile && storedFile.format === 'image';

                    // Â≠êË¶ÅÁ¥†„ÅÆÊï∞„Çí„Ç´„Ç¶„É≥„Éà
                    const children = Array.from(root.children);
                    const rowCount = children.length || (root.textContent.trim() ? 1 : 0);

                    let html = `<table class="kv" style="margin-top: 0.5rem; background: rgba(0,0,0,0.02); width: 100%;">
            <tbody>`;

                    // Â≠êË¶ÅÁ¥†„Åå„ÅÇ„ÇãÂ†¥Âêà
                    if (children.length > 0) {
                        children.forEach((child, index) => {
                            const val = child.children.length > 0 ? child.innerHTML : child.textContent;
                            if (index === 0 && isImage) {
                                // ÊúÄÂàù„ÅÆË°å„Å´ÁîªÂÉè„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫Ôºàrowspan„ÅßË§áÊï∞Ë°å„Å´„Åæ„Åü„Åå„ÇãÔºâ
                                html += `<tr>
                                    <th style="width:1%; white-space:nowrap;">${esc(child.tagName)}</th>
                                    <td>${esc(val)}</td>
                                    <td style="text-align:center; vertical-align:middle; padding:2px;" rowspan="${rowCount}">${getImagePreview(insertionId, storedFile)}</td>
                                </tr>`;
                            } else {
                                html += `<tr>
                                    <th style="width:1%; white-space:nowrap;">${esc(child.tagName)}</th>
                                    <td>${esc(val)}</td>
                                </tr>`;
                            }
                        });
                    } else if (root.textContent.trim()) {
                        // Â±ûÊÄß„ÇÇÂ≠êË¶ÅÁ¥†„ÇÇ„Å™„Åè„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Å†„Åë„ÅÆÂ†¥Âêà
                        const previewCell = isImage ? `<td style="text-align:center; vertical-align:middle; padding:2px;">${getImagePreview(insertionId, storedFile)}</td>` : '';
                        html += `<tr>
                            <th style="width:1%; white-space:nowrap;">Value</th>
                            <td>${esc(root.textContent)}</td>
                            ${previewCell}
                        </tr>`;
                    }

                    html += `</tbody></table>`;
                    return html;
                } catch (e) {
                    return `<pre class="xml-snip">${esc(xmlString)}</pre>`;
                }
            }

            /**
                         * ÁîªÂÉè„Éó„É¨„Éì„É•„Éº„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
                         * @param {string} insertionId - insertionË¶ÅÁ¥†„ÅÆID
                         * @param {object} storedFile - ‰øùÂ≠ò„Åï„Çå„Åü„Éï„Ç°„Ç§„É´ÊÉÖÂ†±
                         */
            function getImagePreview(insertionId, storedFile) {
                if (!storedFile || storedFile.format !== 'image') return '';

                try {
                    let imageUrl = '';

                    if (storedFile.fileData.type === 'tiff') {
                        // TIFF„ÅÆÂ†¥Âêà„ÅØ„Éó„É¨„Éì„É•„ÉºÁî®„ÅÆdiv„ÇíËøî„Åó„ÄÅÂæå„ÅßÈùûÂêåÊúü„ÅßÊèèÁîª
                        const previewId = `tiff-preview-${insertionId}`;
                        // ÈùûÂêåÊúü„ÅßTIFFÁîªÂÉè„ÇíÊèèÁîª
                        setTimeout(() => {
                            renderTiffPreview(previewId, insertionId, storedFile.fileData.data);
                        }, 100);
                        // margin: 0 auto „ÇíËøΩÂä†„Åó„Å¶‰∏≠Â§ÆÂØÑ„Åõ„Å´„Åô„Çã
                        return `<div id="${previewId}" style="width:70px; height:48px; margin: 0 auto; display:flex; align-items:center; justify-content:center; border:1px solid var(--border); border-radius:4px; background:var(--bg); font-size:9px; color:var(--muted); cursor:pointer;" 
                            onclick="event.stopPropagation(); document.querySelector('[data-insertion-id=\\'${esc(insertionId)}\\']').click();"
                            title="Click to view full size">Loading...</div>`;
                    } else if (storedFile.fileData.type === 'image') {
                        imageUrl = storedFile.fileData.data;
                    } else if (storedFile.file && storedFile.file instanceof File) {
                        imageUrl = URL.createObjectURL(storedFile.file);
                    }

                    if (imageUrl) {
                        // event.stopPropagation() „ÇíËøΩÂä†„Åó„Å¶„Ç§„Éô„É≥„Éà„ÅÆ‰ºùÊí≠„ÇíÈò≤„Åê
                        return `<img src="${esc(imageUrl)}" 
                            style="max-width:70px; max-height:48px; object-fit:contain; border:1px solid var(--border); border-radius:4px; cursor:pointer;" 
                            onclick="event.stopPropagation(); document.querySelector('[data-insertion-id=\\'${esc(insertionId)}\\']').click();"
                            title="Click to view full size" />`;
                    }
                } catch (e) {
                    console.error('Error generating image preview:', e);
                }

                return '';
            }

            /**
                         * TIFFÁîªÂÉè„ÅÆ„Éó„É¨„Éì„É•„Éº„ÇíÈùûÂêåÊúü„ÅßÊèèÁîª„Åô„ÇãÈñ¢Êï∞
                         * @param {string} previewId - „Éó„É¨„Éì„É•„ÉºÁî®div„ÅÆID
                         * @param {string} insertionId - insertionË¶ÅÁ¥†„ÅÆID
                         * @param {ArrayBuffer} tiffData - TIFFÁîªÂÉè„ÅÆ„Éá„Éº„Çø
                         */
            async function renderTiffPreview(previewId, insertionId, tiffData) {
                try {
                    const previewDiv = document.getElementById(previewId);
                    if (!previewDiv) return;

                    if (typeof UTIF === 'undefined') {
                        previewDiv.textContent = 'UTIF not loaded';
                        return;
                    }

                    const uint8Array = new Uint8Array(tiffData);
                    const ifds = UTIF.decode(uint8Array);

                    if (!ifds || ifds.length === 0) {
                        previewDiv.textContent = 'Parse error';
                        return;
                    }

                    const ifd = ifds[0];
                    UTIF.decodeImage(uint8Array, ifd);

                    const canvas = document.createElement('canvas');
                    const scale = Math.min(70 / ifd.width, 48 / ifd.height, 1);
                    canvas.width = Math.floor(ifd.width * scale);
                    canvas.height = Math.floor(ifd.height * scale);
                    const ctx = canvas.getContext('2d');

                    const rgba = UTIF.toRGBA8(ifd);
                    const imageData = new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height);

                    // ‰∏ÄÊôÇÁöÑ„Å™canvas„Åß„Éï„É´„Çµ„Ç§„Ç∫„ÅÆÁîªÂÉè„ÇíÊèèÁîª
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = ifd.width;
                    tempCanvas.height = ifd.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);

                    // „Çπ„Ç±„Éº„É´„ÉÄ„Ç¶„É≥„Åó„Å¶ÊèèÁîª
                    ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);

                    // --- „Çπ„Çø„Ç§„É´Ë®≠ÂÆö ---
                    canvas.style.maxWidth = '70px';
                    canvas.style.maxHeight = '48px';
                    canvas.style.objectFit = 'contain';
                    canvas.style.cursor = 'pointer';
                    canvas.style.borderRadius = '4px';
                    // ‰∏≠Â§ÆÂØÑ„Åõ
                    canvas.style.display = 'block';
                    canvas.style.margin = '0 auto';

                    // „Äê‰øÆÊ≠£„ÄëCanvasËá™‰Ωì„Å´Êû†Á∑ö„ÇíË®≠ÂÆöÔºà‰ªñ„ÅÆÁîªÂÉèÂΩ¢Âºè„Å®Âêà„Çè„Åõ„ÇãÔºâ
                    canvas.style.border = '1px solid var(--border)';

                    canvas.onclick = function (e) {
                        // „Ç§„Éô„É≥„Éà„ÅÆ‰ºùÊí≠„ÇíÊ≠¢„ÇÅ„Å¶‰∫åÈáçËµ∑Âãï„ÇíÈò≤„Åê
                        e.stopPropagation();
                        const btn = document.querySelector(`[data-insertion-id="${insertionId}"]`);
                        if (btn) btn.click();
                    };

                    // „Äê‰øÆÊ≠£„ÄëË¶™div„ÅÆÊû†Á∑ö„Å®ËÉåÊôØ„ÇíÂâäÈô§ÔºàCanvas„Å´Êû†„ÇíÁßªË≠≤„Åó„Åü„Åü„ÇÅÔºâ
                    previewDiv.style.border = 'none';
                    previewDiv.style.background = 'transparent';

                    previewDiv.innerHTML = '';
                    previewDiv.appendChild(canvas);
                } catch (e) {
                    console.error('TIFF preview error:', e);
                    const previewDiv = document.getElementById(previewId);
                    if (previewDiv) previewDiv.textContent = 'Error';
                }
                try {
                    const previewDiv = document.getElementById(previewId);
                    if (!previewDiv) return;

                    if (typeof UTIF === 'undefined') {
                        previewDiv.textContent = 'UTIF not loaded';
                        return;
                    }

                    const uint8Array = new Uint8Array(tiffData);
                    const ifds = UTIF.decode(uint8Array);

                    if (!ifds || ifds.length === 0) {
                        previewDiv.textContent = 'Parse error';
                        return;
                    }

                    const ifd = ifds[0];
                    UTIF.decodeImage(uint8Array, ifd);

                    const canvas = document.createElement('canvas');
                    const scale = Math.min(70 / ifd.width, 48 / ifd.height, 1);
                    canvas.width = Math.floor(ifd.width * scale);
                    canvas.height = Math.floor(ifd.height * scale);
                    const ctx = canvas.getContext('2d');

                    const rgba = UTIF.toRGBA8(ifd);
                    const imageData = new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height);

                    // ‰∏ÄÊôÇÁöÑ„Å™canvas„Åß„Éï„É´„Çµ„Ç§„Ç∫„ÅÆÁîªÂÉè„ÇíÊèèÁîª
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = ifd.width;
                    tempCanvas.height = ifd.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);

                    // „Çπ„Ç±„Éº„É´„ÉÄ„Ç¶„É≥„Åó„Å¶ÊèèÁîª
                    ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);

                    canvas.style.maxWidth = '70px';
                    canvas.style.maxHeight = '48px';
                    canvas.style.objectFit = 'contain';
                    canvas.style.cursor = 'pointer';
                    canvas.style.borderRadius = '4px';
                    // ‰∏≠Â§ÆÂØÑ„Åõ„ÇíÁ¢∫ÂÆü„Å´„Åô„Çã
                    canvas.style.display = 'block';
                    canvas.style.margin = '0 auto';

                    canvas.onclick = function (e) {
                        // --- „Äê‰øÆÊ≠£„Äë„Ç§„Éô„É≥„Éà„ÅÆ‰ºùÊí≠„ÇíÊ≠¢„ÇÅ„Å¶‰∫åÈáçËµ∑Âãï„ÇíÈò≤„Åê ---
                        e.stopPropagation();
                        const btn = document.querySelector(`[data-insertion-id="${insertionId}"]`);
                        if (btn) btn.click();
                    };

                    previewDiv.innerHTML = '';
                    previewDiv.appendChild(canvas);
                } catch (e) {
                    console.error('TIFF preview error:', e);
                    const previewDiv = document.getElementById(previewId);
                    if (previewDiv) previewDiv.textContent = 'Error';
                }
            }

            function showStoredFile(insertionId) {
                const stored = insertionFiles.get(insertionId);
                if (!stored) return;

                const viewModal = document.createElement('div');
                viewModal.className = 'modal-overlay show';
                viewModal.innerHTML = `
        <div class="modal-content" style="max-width:80vw; max-height:80vh;">
          <div class="modal-header">
            <h3>${stored.file.name}</h3>
            <button class="modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="preview-area" style="display:flex;" id="storedPreview">
              <p>Loading...</p>
            </div>
            <div style="margin-top:1rem; display:flex; gap:0.5rem; justify-content:flex-end;">
              <button class="btn change-btn">change to another file</button>
              <button class="btn primary close-btn">Close</button>
            </div>
          </div>
        </div>
      `;

                document.body.appendChild(viewModal);

                const previewContainer = viewModal.querySelector('#storedPreview');
                renderStoredFile(stored, previewContainer);

                viewModal.querySelector('.modal-close').addEventListener('click', () => {
                    document.body.removeChild(viewModal);
                });

                viewModal.querySelector('.close-btn').addEventListener('click', () => {
                    document.body.removeChild(viewModal);
                });

                viewModal.querySelector('.change-btn').addEventListener('click', () => {
                    document.body.removeChild(viewModal);
                    openUploadModal(insertionId);
                });

                viewModal.addEventListener('click', (e) => {
                    if (e.target === viewModal) document.body.removeChild(viewModal);
                });
            }

            async function renderStoredFile(stored, container) {
                try {
                    if (stored.format === 'image') {
                        if (stored.fileData.type === 'tiff') {
                            container.innerHTML = '<p>Loading TIFF file...</p>';

                            const uint8Array = new Uint8Array(stored.fileData.data);
                            const ifds = UTIF.decode(uint8Array);

                            if (!ifds || ifds.length === 0) {
                                throw new Error('Failed to parse TIFF file');
                            }

                            const ifd = ifds[0];
                            UTIF.decodeImage(uint8Array, ifd);

                            const canvas = document.createElement('canvas');
                            canvas.width = ifd.width;
                            canvas.height = ifd.height;
                            const ctx = canvas.getContext('2d');

                            const rgba = UTIF.toRGBA8(ifd);
                            const imageData = new ImageData(new Uint8ClampedArray(rgba), ifd.width, ifd.height);
                            ctx.putImageData(imageData, 0, 0);

                            container.innerHTML = '';
                            canvas.style.maxWidth = '100%';
                            canvas.style.height = 'auto';
                            canvas.style.borderRadius = '4px';
                            container.appendChild(canvas);

                            const info = document.createElement('p');
                            info.style.marginTop = '0.5rem';
                            info.style.fontSize = '12px';
                            info.style.color = 'var(--muted)';
                            info.textContent = `Image Size: ${ifd.width} √ó ${ifd.height} px | TIFF format`;
                            container.appendChild(info);

                        } else if (stored.fileData.type === 'image') {
                            container.innerHTML = '';
                            const img = document.createElement('img');
                            img.src = stored.fileData.data;
                            img.style.maxWidth = '100%';
                            img.style.height = 'auto';
                            img.style.borderRadius = '4px';
                            container.appendChild(img);
                        }
                    } else if (stored.format === 'chart') {
                        // ‚òÖ ChartÂΩ¢Âºè„ÅÆ‰øÆÊ≠£
                        container.innerHTML = '<p>Loading chart...</p>';

                        const text = await stored.fileData.data.text();
                        const parsed = Papa.parse(text, { header: true, dynamicTyping: true });

                        if (parsed.errors.length > 0) {
                            throw new Error('CSV parsing error');
                        }

                        const data = parsed.data.filter(row => Object.values(row).some(v => v !== null && v !== ''));
                        const headers = Object.keys(data[0] || {});

                        if (headers.length < 2) {
                            throw new Error('Insufficient data (at least 2 columns required)');
                        }

                        // canvas„Çí‰ΩúÊàê„Åó„Å¶container„Å´ËøΩÂä†
                        const canvas = document.createElement('canvas');
                        canvas.style.width = '100%';
                        canvas.style.height = '400px';
                        container.innerHTML = '';
                        container.appendChild(canvas);

                        new Chart(canvas, {
                            type: 'line',
                            data: {
                                labels: data.map(row => row[headers[0]]),
                                datasets: headers.slice(1).map((header, i) => ({
                                    label: header,
                                    data: data.map(row => row[header]),
                                    borderColor: `hsl(${i * 60}, 70%, 50%)`,
                                    backgroundColor: `hsla(${i * 60}, 70%, 50%, 0.1)`,
                                    tension: 0.3
                                }))
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: { display: true }
                                }
                            }
                        });

                    } else if (stored.format === 'table') {
                        // ‚òÖ TableÂΩ¢Âºè„ÅÆ‰øÆÊ≠£
                        container.innerHTML = '<p>Loading table...</p>';

                        const file = stored.fileData.data;
                        const name = file.name.toLowerCase();
                        let data;

                        if (name.endsWith('.xlsx') || name.endsWith('.xls') ||
                            file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                            file.type === 'application/vnd.ms-excel') {

                            const arrayBuffer = await file.arrayBuffer();
                            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            data = XLSX.utils.sheet_to_json(worksheet);

                        } else if (name.endsWith('.json')) {
                            const text = await file.text();
                            data = JSON.parse(text);
                            if (!Array.isArray(data)) data = [data];
                        } else {
                            const text = await file.text();
                            const parsed = Papa.parse(text, { header: true });
                            data = parsed.data.filter(row => Object.values(row).some(v => v !== null && v !== ''));
                        }

                        if (data.length === 0) {
                            throw new Error('Data is empty');
                        }

                        const headers = Object.keys(data[0]);
                        let html = '<table style="width:100%; border-collapse:collapse; font-size:12px;">';
                        html += '<thead><tr>';
                        headers.forEach(h => html += `<th style="border:1px solid var(--border); padding:0.5rem; background:var(--table-head);">${h}</th>`);
                        html += '</tr></thead><tbody>';

                        data.slice(0, 100).forEach(row => {
                            html += '<tr>';
                            headers.forEach(h => html += `<td style="border:1px solid var(--border); padding:0.5rem;">${row[h] ?? ''}</td>`);
                            html += '</tr>';
                        });

                        html += '</tbody></table>';
                        if (data.length > 100) html += `<p style="margin-top:0.5rem; color:var(--muted);">(Displaying only the first 100 rows)</p>`;

                        container.innerHTML = html;

                    } else if (stored.format === 'text') {
                        // ‚òÖ TextÂΩ¢Âºè„ÅÆ‰øÆÊ≠£
                        const text = await stored.fileData.data.text();
                        container.innerHTML = `<pre style="white-space:pre-wrap; font-size:12px; max-height:400px; overflow:auto;">${text}</pre>`;
                    } else {
                        container.innerHTML = stored.preview;
                    }
                } catch (err) {
                    console.error('File display error:', err);
                    container.innerHTML = `<p style="color:var(--warn);">Failed to display file: ${err.message}</p>`;
                }
            }


            function renderPropertiesTable(props) {
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';

                const tbl = document.createElement('table');
                tbl.className = 'kv';
                let html = '<tr><th>Key</th><th>Type</th><th>Units</th><th>Format</th><th>Description</th><th>Value</th><th>X axis</th><th>Y axis</th></tr>';

                let contentIndex = 0; // contentË¶ÅÁ¥†„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
                const contentItems = []; // PLOTÁî®„Å´contentË¶ÅÁ¥†„Çí‰øùÂ≠ò

                // ÈöéÂ±§ÁöÑ„Å´Ë°å„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞Ôºàproperty„Å®content„ÅÆ‰∏°Êñπ„Å´ÂØæÂøúÔºâ
                function renderPropertyRow(pr, level = 0) {
                    let rows = '';
                    const indent = '„ÄÄ'.repeat(level); // ÂÖ®Ëßí„Çπ„Éö„Éº„Çπ„Åß„Ç§„É≥„Éá„É≥„Éà

                    let displayValue;
                    const isContent = pr.kind === 'content';

                    if (isContent) {
                        // contentË¶ÅÁ¥†„ÅÆÂ†¥Âêà
                        let values = [];
                        if (Array.isArray(pr.value)) values = pr.value;
                        else if (typeof pr.value === 'string') values = pr.value.split(/[\s,]+/).map(v => v.trim()).filter(v => v);
                        displayValue = values.join(', ');
                    } else {
                        // propertyË¶ÅÁ¥†„ÅÆÂ†¥Âêà
                        if (pr.key && pr.key.includes('List')) {
                            let values = [];
                            if (Array.isArray(pr.value)) values = pr.value;
                            else if (typeof pr.value === 'string') values = pr.value.split(/[\s,]+/).map(v => v.trim()).filter(v => v);
                            displayValue = values.join(', ');
                        } else {
                            displayValue = Array.isArray(pr.value) ? pr.value.join(' ') : (pr.value || '');
                        }
                    }

                    // contentË¶ÅÁ¥†„ÅÆÂ†¥Âêà„ÅØ„É©„Ç∏„Ç™„Éú„Çø„É≥„ÇíË°®Á§∫
                    let xRadio = '', yRadio = '';
                    if (isContent) {
                        const idx = contentIndex;
                        contentItems.push(pr);
                        xRadio = `<input type="radio" name="xSelect" data-idx="${idx}" class="x-select">`;
                        yRadio = `<input type="radio" name="ySelect" data-idx="${idx}" class="y-select">`;
                        contentIndex++;
                    }

                    rows += `<tr data-idx="${isContent ? contentIndex - 1 : ''}">
            <td title="${esc(pr.key || '')}">${esc(indent + (pr.key || ''))}</td>
            <td>${esc(pr.type || '')}</td>
            <td>${esc(pr.units || '')}</td>
            <td>${esc(pr.fstring || '')}</td>
            <td>${esc(pr.description || '')}</td>
            <td>
                <div class="value-cell-scroll">${esc(displayValue)}</div>
            </td>
            <td style="text-align:center;">${xRadio}</td>
            <td style="text-align:center;">${yRadio}</td>
        </tr>`;

                    // Â≠êË¶ÅÁ¥†„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
                    if (pr.children && pr.children.length > 0) {
                        pr.children.forEach(child => {
                            rows += renderPropertyRow(child, level + 1);
                        });
                    }

                    return rows;
                }

                props.forEach(pr => {
                    html += renderPropertyRow(pr, 0);
                });

                tbl.innerHTML = html;
                wrapper.appendChild(tbl);

                // contentË¶ÅÁ¥†„Åå2„Å§‰ª•‰∏ä„ÅÇ„ÇãÂ†¥Âêà„ÅØPLOT„Éú„Çø„É≥„ÇíËøΩÂä†
                if (contentItems.length >= 2) {
                    const btnWrapper = document.createElement('div');
                    btnWrapper.style.display = 'flex';
                    btnWrapper.style.justifyContent = 'flex-end';
                    btnWrapper.style.marginTop = '0.5rem';

                    const plotBtn = document.createElement('button');
                    plotBtn.className = 'btn primary';
                    plotBtn.textContent = 'üìà PLOT';
                    plotBtn.addEventListener('click', () => {
                        const xIdx = wrapper.querySelector('.x-select:checked')?.dataset.idx;
                        const yIdx = wrapper.querySelector('.y-select:checked')?.dataset.idx;

                        if (xIdx == null || yIdx == null) {
                            alert('Please select one X axis and one Y axis.');
                            return;
                        }

                        const xRow = contentItems[xIdx];
                        const yRow = contentItems[yIdx];

                        const xVals = parseValues(xRow.value);
                        const yVals = parseValues(yRow.value);

                        if (xVals.length !== yVals.length) {
                            alert(`The number of data points for X and Y axes do not match.\nX=${xVals.length} points, Y=${yVals.length} points`);
                            return;
                        }

                        showXYPlotModal(xRow.key || 'X', yRow.key || 'Y', xVals, yVals);
                    });

                    btnWrapper.appendChild(plotBtn);
                    wrapper.appendChild(btnWrapper);
                }

                return wrapper;
            }

            function renderContentsTable(conts) {
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';

                const tbl = document.createElement('table');
                tbl.className = 'kv';

                let html = `
    <tr>
        <th>Key</th>
        <th>Type</th>
        <th>Units</th>
        <th>Format</th>
        <th>Description</th>
        <th>Values</th>
        <th>X axis</th>
        <th>Y axis</th>
    </tr>
    `;

                // ÈöéÂ±§ÁöÑ„Å´Ë°å„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
                function renderContentRow(c, idx, level = 0) {
                    let rows = '';
                    const indent = '„ÄÄ'.repeat(level); // ÂÖ®Ëßí„Çπ„Éö„Éº„Çπ„Åß„Ç§„É≥„Éá„É≥„Éà

                    let values = [];
                    if (Array.isArray(c.value)) values = c.value;
                    else if (typeof c.value === 'string') values = c.value.split(/[\s,]+/).map(v => v.trim()).filter(v => v);

                    rows += `<tr data-idx="${idx}">
        <td>${esc(indent + (c.key || ''))}</td>
        <td>${esc(c.type || '')}</td>
        <td>${esc(c.units || '')}</td>
        <td>${esc(c.fstring || '')}</td>
        <td>${esc(c.description || '')}</td>
        <td>
            <div class="value-cell-scroll">${esc(values.join(', '))}</div>
        </td>
        <td style="text-align:center;"><input type="radio" name="xSelect" data-idx="${idx}" class="x-select"></td>
        <td style="text-align:center;"><input type="radio" name="ySelect" data-idx="${idx}" class="y-select"></td>
        </tr>`;

                    // Â≠êË¶ÅÁ¥†„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜÔºà„Åü„Å†„Åó„É©„Ç∏„Ç™„Éú„Çø„É≥„ÅØË¶™„ÅÆ„ÅøÔºâ
                    if (c.children && c.children.length > 0) {
                        c.children.forEach(child => {
                            let childValues = [];
                            if (Array.isArray(child.value)) childValues = child.value;
                            else if (typeof child.value === 'string') childValues = child.value.split(/[\s,]+/).map(v => v.trim()).filter(v => v);

                            const childIndent = '„ÄÄ'.repeat(level + 1);
                            rows += `<tr>
                <td>${esc(childIndent + (child.key || ''))}</td>
                <td>${esc(child.type || '')}</td>
                <td>${esc(child.units || '')}</td>
                <td>${esc(child.fstring || '')}</td>
                <td>${esc(child.description || '')}</td>
                <td>
                    <div class="value-cell-scroll">${esc(childValues.join(', '))}</div>
                </td>
                <td></td>
                <td></td>
                </tr>`;
                        });
                    }

                    return rows;
                }

                conts.forEach((c, idx) => {
                    html += renderContentRow(c, idx, 0);
                });

                tbl.innerHTML = html;
                wrapper.appendChild(tbl);

                const btn = document.createElement('button');
                btn.className = 'btn primary';
                btn.textContent = 'üìà PLOT';
                btn.style.marginTop = '0.5rem';

                btn.addEventListener('click', () => {
                    const xIdx = wrapper.querySelector('.x-select:checked')?.dataset.idx;
                    const yIdx = wrapper.querySelector('.y-select:checked')?.dataset.idx;

                    if (xIdx == null || yIdx == null) {
                        alert('Please select one X axis and one Y axis.');
                        return;
                    }
                    const xRow = conts[xIdx];
                    const yRow = conts[yIdx];

                    const xVals = parseValues(xRow.value);
                    const yVals = parseValues(yRow.value);

                    if (xVals.length !== yVals.length) {
                        alert(`The number of data points for X and Y axes do not match.\nX=${xVals.length} points, Y=${yVals.length} points`);
                        return;
                    }

                    showXYPlotModal(xRow.key || 'X', yRow.key || 'Y', xVals, yVals);
                });

                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '0.5rem';

                container.appendChild(wrapper);

                const btnWrapper = document.createElement('div');
                btnWrapper.style.display = 'flex';
                btnWrapper.style.justifyContent = 'flex-end';
                btnWrapper.appendChild(btn);

                container.appendChild(btnWrapper);
                return container;
            }

            function showXYPlotModal(xLabel, yLabel, xVals, yVals) {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay show';
                modal.innerHTML = `
          <div class="modal-content" style="max-width:70vw; max-height:80vh;">
            <div class="modal-header">
              <h3>PLOT: ${esc(yLabel)} vs ${esc(xLabel)}</h3>
              <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
              <canvas id="xyPlotCanvas" style="width:100%; height:400px;"></canvas>
            </div>
          </div>
        `;

                document.body.appendChild(modal);
                modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
                modal.addEventListener('click', e => {
                    if (e.target === modal) modal.remove();
                });

                const ctx = modal.querySelector('#xyPlotCanvas');
                const dataPoints = xVals.map((x, i) => ({ x: x, y: yVals[i] }));

                new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: `${yLabel} vs ${xLabel}`,
                            data: dataPoints,
                            borderColor: 'rgba(25,118,210,1)',
                            backgroundColor: 'rgba(25,118,210,0.2)',
                            showLine: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: { title: { display: true, text: xLabel } },
                            y: { title: { display: true, text: yLabel } }
                        }
                    }
                });
            }

            function parseValues(val) {
                if (Array.isArray(val)) return val.map(v => parseFloat(v)).filter(v => !isNaN(v));
                if (typeof val === 'string')
                    return val.split(/[\s,]+/).map(v => parseFloat(v)).filter(v => !isNaN(v));
                return [];
            }

            function esc(s) {
                return (s == null ? '' : (s + '')).replace(/[&<>"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;" }[c]));
            }

            ;
            (function demo() {
                nodes = [
                    { id: 'place_Material', type: 'place', label: 'MaterialPlace', r: 18 },
                    { id: 'place_Condition', type: 'place', label: 'ConditionPlace', r: 18 },
                    { id: 'transition1', type: 'transition', label: 'measurementTransition', w: 24, h: 50 },
                    { id: 'place_Result', type: 'place', label: 'ResultPlace', r: 18 }
                ];
                links = [
                    { source: 'place_Material', target: 'transition1' },
                    { source: 'place_Condition', target: 'transition1' },
                    { source: 'transition1', target: 'place_Result' }
                ];
                render();
                runAutoLayout(true);
                updateStats();
            })();
            window.nodes = nodes;
            window.links = links;
            window.templateById = templateById;
            window.instances = instances;
            window.placeToTemplates = placeToTemplates;
            window.templateToInstances = templateToInstances;
        })();
    </script>

    <!-- <script>
        // Gemini key button
        (function () {
            const themeBtn = document.getElementById("themeBtn");
            if (!themeBtn) return;
            const gemBtn = document.createElement('button');
            gemBtn.className = 'btn';
            gemBtn.id = 'geminiKeyBtn';
            gemBtn.textContent = 'üîë Gemini API Key';
            themeBtn.before(gemBtn);
            function refresh() { gemBtn.style.background = localStorage.getItem("geminiApiKey") ? '#3c6' : ''; }
            refresh();
            gemBtn.addEventListener('click', () => {
                const key = prompt("Please enter your Google Gemini API Key\nhttps://aistudio.google.com/", localStorage.getItem("geminiApiKey") || "");
                if (key === null) return;
                if (key.trim() === "") { localStorage.removeItem("geminiApiKey"); }
                else { localStorage.setItem("geminiApiKey", key.trim()); }
                refresh();
            });
        })();
    </script> -->
    <script>
        // Gemini key button with Custom Modal
        (function () {
            const themeBtn = document.getElementById("themeBtn");
            if (!themeBtn) return;

            // 1. „Éú„Çø„É≥„ÅÆ‰ΩúÊàê
            const gemBtn = document.createElement('button');
            gemBtn.className = 'btn';
            gemBtn.id = 'geminiKeyBtn';
            gemBtn.textContent = 'üîë Gemini API Key';
            themeBtn.before(gemBtn);

            // 2. „É¢„Éº„ÉÄ„É´HTML„ÅÆÊ≥®ÂÖ•
            const modalHtml = `
            <div class="modal-overlay" id="apiKeyModal">
                <div class="modal-content" style="max-width: 450px;">
                    <div class="modal-header">
                        <h3>Gemini API Key Settings</h3>
                        <button class="modal-close" id="apiKeyClose">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem; line-height: 1.5;">
                            To use AI summary features, please set your Gemini API Key.<br>
                            You can get a free key from: <br>
                            <a href="https://aistudio.google.com/" target="_blank" style="color:var(--accent); text-decoration:underline; font-weight:bold;">
                                Google AI Studio üîó
                            </a>
                        </p>
                        <label style="font-size:12px; font-weight:600;">API Key:</label>
                        <input type="password" id="apiKeyInput" placeholder="Paste your API Key here" style="width: 100%; padding: 0.5rem; margin: 0.5rem 0 1.5rem;" autocomplete="off" />
                        
                        <div style="display: flex; justify-content: space-between; gap: 0.5rem;">
                            <button class="btn" id="removeKeyBtn" style="color:var(--warn); border-color:var(--warn);">üóëÔ∏è Remove Key</button>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="btn" id="cancelKeyBtn">Cancel</button>
                                <button class="btn primary" id="saveKeyBtn">Save</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // 3. Ë¶ÅÁ¥†„ÅÆÂèñÂæó
            const modal = document.getElementById('apiKeyModal');
            const input = document.getElementById('apiKeyInput');
            const saveBtn = document.getElementById('saveKeyBtn');
            const removeBtn = document.getElementById('removeKeyBtn');
            const cancelBtn = document.getElementById('cancelKeyBtn');
            const closeBtn = document.getElementById('apiKeyClose');

            // 4. Ë°®Á§∫Êõ¥Êñ∞„É≠„Ç∏„ÉÉ„ÇØ
            function refresh() {
                const key = localStorage.getItem("geminiApiKey");
                if (key) {
                    gemBtn.style.background = '#3c6';
                    gemBtn.style.color = '#fff';
                    gemBtn.style.borderColor = '#2a9';
                } else {
                    gemBtn.style.background = '';
                    gemBtn.style.color = '';
                    gemBtn.style.borderColor = '';
                }
            }
            refresh();

            // 5. „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©
            gemBtn.addEventListener('click', () => {
                // „Ç≠„Éº„ÇíË™≠„ÅøËæº„ÇÄ„Åå„ÄÅinput„ÅØpassword„Çø„Ç§„Éó„Å™„ÅÆ„ÅßË°®Á§∫„ÅØ„Éû„Çπ„ÇØ„Åï„Çå„Çã
                input.value = localStorage.getItem("geminiApiKey") || "";
                modal.classList.add('show');
                input.focus();
            });

            function closeModal() {
                modal.classList.remove('show');
            }

            saveBtn.addEventListener('click', () => {
                const val = input.value.trim();
                if (val) {
                    localStorage.setItem("geminiApiKey", val);
                } else {
                    localStorage.removeItem("geminiApiKey");
                }
                refresh();
                closeModal();
            });

            removeBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to remove the API Key?')) {
                    localStorage.removeItem("geminiApiKey");
                    input.value = "";
                    refresh();
                    closeModal();
                }
            });

            [cancelBtn, closeBtn].forEach(btn => btn.addEventListener('click', closeModal));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
        })();
    </script>

    <script>
        // summary dialog
        (function () {
            const modal = document.getElementById("aiSummaryModal");
            const closeBtn = document.getElementById("aiSummaryClose");
            const targetDiv = document.getElementById("aiSummaryTarget");
            const resultDiv = document.getElementById("aiSummaryResult");
            const copyBtn = document.getElementById("copySummaryBtn");
            const promptTemplateSel = document.getElementById("promptTemplate");

            let rawTextContent = '';
            let currentText = ''; // ÁèæÂú®„ÅÆÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„Éà„Çí‰øùÊåÅ

            const promptTemplates = {
                quick: {  // „Éá„Éï„Ç©„É´„Éà„ÄÅËªΩÈáè
                    ja: "‰ª•‰∏ã„ÅÆÊÉÖÂ†±„Çí2„Äú3ÊñáÁ®ãÂ∫¶„ÅßÁ∞°ÊΩî„Å´„Åæ„Å®„ÇÅ„ÄÅÁÆáÊù°Êõ∏„Åç„Å®MarkdownÂΩ¢Âºè„ÅßÁ§∫„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n{TEXT}",
                    en: "Summarize the following information in 2-3 sentences using bullet points in Markdown. Focus on key points:\n{TEXT}",
                    other: "Summarize the following information in 2-3 sentences using bullet points in Markdown. Please respond in {LANG} and focus on key points:\n{TEXT}"
                },
                standard: {  // Ê®ôÊ∫ñË¶ÅÁ¥Ñ
                    ja: "‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„Çí5„Äú7ÊñáÁ®ãÂ∫¶„ÅßË¶ÅÁ¥Ñ„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë°®„Çí‰ΩøÁî®„Åó„ÅüMarkdownÂΩ¢Âºè„ÅÆ„É¨„Éù„Éº„Éà„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n{TEXT}",
                    en: "Summarize the following text in approximately 5-7 sentences and generate a Markdown report using tables if appropriate:\n{TEXT}",
                    other: "Summarize the following text in approximately 5-7 sentences and generate a Markdown report using tables if appropriate. Please respond in {LANG}:\n{TEXT}"
                },
                detailed: {  // Ë©≥Á¥∞ÂàÜÊûê„ÉªÂ†±ÂëäÊõ∏
                    ja: "‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„Å´„Å§„ÅÑ„Å¶10„Äú15ÊñáÁ®ãÂ∫¶„ÅßË©≥Á¥∞„Å™ÂàÜÊûê„É¨„Éù„Éº„Éà„Çí‰ΩúÊàê„Åó„ÄÅË¶ãÂá∫„Åó„ÄÅË°®„ÄÅÂº∑Ë™ø„ÇíÁî®„ÅÑ„ÅüMarkdownÂΩ¢Âºè„ÅßÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö\n{TEXT}",
                    en: "Create a detailed analytical report of the following content in approximately 10-15 sentences, using headings, tables, and emphasis in Markdown format:\n{TEXT}",
                    other: "Create a detailed analytical report of the following content in approximately 10-15 sentences, using headings, tables, and emphasis in Markdown format. Please respond in {LANG}:\n{TEXT}"
                }
            };

            // Summary Type„ÅåÂ§âÊõ¥„Åï„Çå„Åü„ÇâÂÜçË¶ÅÁ¥Ñ
            promptTemplateSel.addEventListener("change", () => {
                if (currentText && modal.classList.contains("show")) {
                    resultDiv.textContent = "Regenerating summary...";
                    resultDiv.classList.add("markdown-content");
                    runGemini(currentText);
                }
            });

            window.openAISummaryDialog = function (text) {
                currentText = text; // „ÉÜ„Ç≠„Çπ„Éà„Çí‰øùÂ≠ò
                modal.classList.add("show");
                targetDiv.style.display = "block";
                targetDiv.textContent = text;
                resultDiv.textContent = "Generating summary...";
                resultDiv.classList.add("markdown-content");
                copyBtn.textContent = 'üìã Copy';
                runGemini(text);
            };

            closeBtn.addEventListener("click", () => {
                modal.classList.remove("show");
                currentText = ''; // „É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Åü„Çâ„ÇØ„É™„Ç¢
            });

            copyBtn.addEventListener("click", async () => {
                const textToCopy = rawTextContent || resultDiv.textContent;
                if (!textToCopy || textToCopy === 'Generating summary...' || textToCopy === 'Regenerating summary...' || textToCopy === 'API Key not set' || textToCopy.startsWith('Network error')) {
                    return;
                }
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    copyBtn.textContent = '‚úÖ Copied!';
                    setTimeout(() => copyBtn.textContent = 'üìã Copy', 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    copyBtn.textContent = '‚ùå Copy failed';
                    setTimeout(() => copyBtn.textContent = 'üìã Copy', 2000);
                    alert('Failed to write to clipboard. Please check your browser permissions.');
                }
            });

            document.getElementById("saveSummaryBtn").addEventListener("click", () => {
                const textToSave = rawTextContent || resultDiv.textContent;

                if (!textToSave) {
                    alert("No summary to save.");
                    return;
                }

                const blob = new Blob([textToSave], { type: "text/markdown" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = "AIsummary.md";
                a.click();

                URL.revokeObjectURL(url);
            });



            function getPrompt(text, lang) {
                const template = promptTemplateSel.value;
                const promptSet = promptTemplates[template] || promptTemplates.default;
                const langKey = lang === 'ja' ? 'ja' : lang === 'en' ? 'en' : 'other';

                return promptSet[langKey]
                    .replace('{TEXT}', text)
                    .replace('{LANG}', lang);
            }

            async function runGemini(text) {
                const key = localStorage.getItem("geminiApiKey");
                if (!key) {
                    resultDiv.textContent = "API Key not set";
                    resultDiv.classList.remove("markdown-content");
                    return;
                }

                // --- „Åì„Åì„Åß„É¢„Éá„É´Âêç„ÇíÂèñÂæóÔºàÊú™ÂÖ•ÂäõÊôÇ„ÅØ„Éá„Éï„Ç©„É´„ÉàÔºâ ---
                const modelName = document.getElementById("modelName")?.value?.trim() || "gemini-2.5-flash";

                // --- Á∞°Âçò„Å™„Éê„É™„Éá„Éº„Ç∑„Éß„É≥ÔºàËã±Êï∞Â≠ó„ÄÅ„Éè„Ç§„Éï„É≥„ÄÅ„Éâ„ÉÉ„Éà„ÄÅ„Ç¢„É≥„ÉÄ„Éº„Çπ„Ç≥„Ç¢„ÅÆ„ÅøÔºâ---
                if (!/^[\w\.\-:]+$/.test(modelName)) {
                    resultDiv.textContent = "Invalid model name (contains illegal characters).";
                    resultDiv.classList.remove("markdown-content");
                    return;
                }

                const browserLang = navigator.language || navigator.userLanguage;
                const langCode = browserLang.split('-')[0];
                const prompt = getPrompt(text, langCode);

                const url = `https://generativelanguage.googleapis.com/v1/models/${modelName}:generateContent?key=${key}`;

                const body = { contents: [{ parts: [{ text: prompt }] }] };

                try {
                    const res = await fetch(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(body)
                    });
                    const data = await res.json();

                    if (data.error) {
                        rawTextContent = `API Error: ${data.error.message}`;
                        resultDiv.textContent = rawTextContent;
                        resultDiv.classList.remove("markdown-content");
                    } else {
                        rawTextContent = data.candidates[0].content.parts[0].text.trim();

                        if (typeof marked !== 'undefined') {
                            resultDiv.innerHTML = marked.parse(rawTextContent);
                            resultDiv.classList.add("markdown-content");

                            // Ê≥®ÊÑèÊõ∏„Åç„ÇíËøΩÂä†
                            const disclaimer = document.createElement('div');
                            disclaimer.className = 'ai-disclaimer';
                            if (langCode === 'ja') {
                                disclaimer.textContent = '„Åì„ÅÆË¶ÅÁ¥Ñ„ÅØAI„Å´„Çà„Å£„Å¶ÁîüÊàê„Åï„Çå„Åü„ÇÇ„ÅÆ„Åß„ÅÇ„Çä„ÄÅÂøÖ„Åö„Åó„ÇÇÊ≠£Á¢∫„Å®„ÅØÈôê„Çä„Åæ„Åõ„Çì„ÄÇÈáçË¶Å„Å™ÊÉÖÂ†±„Å´„Å§„ÅÑ„Å¶„ÅØÂÖÉ„Éá„Éº„Çø„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ';
                            } else {
                                disclaimer.textContent = 'This summary was generated by AI and may not be entirely accurate. Please verify important information against the original data.';
                            }
                            resultDiv.appendChild(disclaimer);
                        } else {
                            resultDiv.textContent = rawTextContent;
                            resultDiv.classList.remove("markdown-content");
                        }
                    }
                } catch (e) {
                    rawTextContent = `Network error or API call failed: ${e.message}`;
                    resultDiv.textContent = rawTextContent;
                    resultDiv.classList.remove("markdown-content");
                }
            }
        })();
    </script>

    <script>
        // =============================================================================
        // MaiMLViewer „É°„Çø„Éá„Éº„ÇøExportÊ©üËÉΩËøΩÂä†„Ç≥„Éº„Éâ (‰øÆÊ≠£Áâà)
        // =============================================================================

        // „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÂ§âÊï∞„ÅåÂÖ¨Èñã„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
        console.log('Checking global variables...');
        console.log('window.nodes:', window.nodes);
        console.log('window.templateById:', window.templateById);
        console.log('window.instances:', window.instances);

        // 1. „ÉÑ„Éº„É´„Éê„Éº„Å´Export„Éú„Çø„É≥„ÇíËøΩÂä†
        (function addExportButton() {
            const toolbar = document.getElementById('toolbar');
            const themeBtn = document.getElementById('themeBtn');

            if (!toolbar || !themeBtn) {
                console.error('Toolbar or theme button not found!');
                return;
            }

            const exportBtn = document.createElement('button');
            exportBtn.className = 'btn';
            exportBtn.id = 'exportMetadataBtn';
            exportBtn.textContent = 'üìä Export Metadata';
            themeBtn.before(exportBtn);

            exportBtn.addEventListener('click', function () {
                console.log('Export button clicked!');
                openExportModal();
            });

            console.log('Export button added successfully');
        })();

        // 2. Export„É¢„Éº„ÉÄ„É´„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíËøΩÂä†
        (function createExportModal() {
            const modalHtml = `
        <div class="modal-overlay" id="exportModal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h3>üìä Export Metadata</h3>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 1rem; line-height: 1.5;">
                        Export all metadata (properties and contents) from the loaded MaiML file.
                    </p>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <label style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 0.5rem;">
                            Select Export Format:
                        </label>
<div class="format-selector" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.8rem;">
    <div class="format-option" data-format="excel" style="cursor: pointer; border: 2px solid var(--border); padding: 1rem; border-radius: 8px; text-align: center; background: var(--surface); color: var(--ink); transition: all 0.2s;">
        <div style="font-size: 32px; margin-bottom: 0.5rem;">üìó</div>
        <div>Excel (.xlsx)</div>
    </div>
    <div class="format-option selected" data-format="json" style="cursor: pointer; border: 2px solid var(--accent); padding: 1rem; border-radius: 8px; text-align: center; background: var(--accent); color: #fff; transition: all 0.2s;">
        <div style="font-size: 32px; margin-bottom: 0.5rem;">üìÑ</div>
        <div>JSON (.json)</div>
    </div>
    <div class="format-option" data-format="csv" style="cursor: pointer; border: 2px solid var(--border); padding: 1rem; border-radius: 8px; text-align: center; background: var(--surface); color: var(--ink); transition: all 0.2s;">
        <div style="font-size: 32px; margin-bottom: 0.5rem;">üìä</div>
        <div>CSV (.csv)</div>
    </div>
</div>
                    </div>
                    
                    <div id="exportStatus" style="padding: 0.5rem; margin-bottom: 1rem; border-radius: 4px; display: none;"></div>
                    
                    <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
                        <button class="btn" id="cancelExportBtn">Cancel</button>
                        <button class="btn primary" id="executeExportBtn">üì• Export</button>
                    </div>
                </div>
            </div>
        </div>
    `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);

            const modal = document.getElementById('exportModal');
            const closeBtn = modal.querySelector('.modal-close');
            const cancelBtn = document.getElementById('cancelExportBtn');
            const exportBtn = document.getElementById('executeExportBtn');
            const formatOptions = modal.querySelectorAll('.format-option');

            let selectedFormat = 'json';  // „Éá„Éï„Ç©„É´„Éà„ÇíJSON„Å´Â§âÊõ¥

            formatOptions.forEach(opt => {
                opt.addEventListener('click', () => {
                    formatOptions.forEach(o => {
                        o.style.border = '2px solid var(--border)';
                        o.style.background = 'var(--surface)';
                        o.style.color = 'var(--ink)';  // „ÉÜ„Éº„ÉûÂØæÂøú„ÅÆËâ≤
                        o.classList.remove('selected');
                    });
                    opt.style.border = '2px solid var(--accent)';
                    opt.style.background = 'var(--accent)';
                    opt.style.color = '#fff';
                    opt.classList.add('selected');
                    selectedFormat = opt.dataset.format;
                    console.log('Selected format:', selectedFormat);
                });
            });

            closeBtn.addEventListener('click', closeExportModal);
            cancelBtn.addEventListener('click', closeExportModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeExportModal();
            });

            exportBtn.addEventListener('click', () => {
                console.log('Execute export with format:', selectedFormat);
                executeExport(selectedFormat);
            });

            console.log('Export modal created successfully');
        })();

        // 3. „É¢„Éº„ÉÄ„É´ÈñãÈñâÈñ¢Êï∞
        function openExportModal() {
            console.log('Opening export modal...');
            const modal = document.getElementById('exportModal');
            const statusDiv = document.getElementById('exportStatus');

            if (!modal) {
                console.error('Export modal not found!');
                return;
            }

            // MaiML„Éï„Ç°„Ç§„É´„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            console.log('Checking if MaiML is loaded...');
            console.log('templateById:', window.templateById);
            console.log('templateById size:', window.templateById ? window.templateById.size : 'undefined');

            if (!window.templateById || window.templateById.size === 0) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'var(--warn)';
                statusDiv.style.color = '#fff';
                statusDiv.textContent = '‚ö†Ô∏è No MaiML file loaded. Please load a file first.';
                modal.classList.add('show');
                return;
            }

            statusDiv.style.display = 'none';
            modal.classList.add('show');
            console.log('Modal opened successfully');
        }

        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            if (modal) {
                modal.classList.remove('show');
                console.log('Modal closed');
            }
        }

        // 4. insertionË¶ÅÁ¥†„Åã„ÇâÊÉÖÂ†±„ÇíÊäΩÂá∫„Åô„ÇãÈñ¢Êï∞
        function extractInsertionInfo(insertion) {
            const result = {
                id: insertion.id || '',
                uri: '',
                hash: '',
                hashMethod: '',
                format: ''
            };

            // element„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÁõ¥Êé•XMLË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            if (insertion.element) {
                const uriEl = insertion.element.querySelector('uri') ||
                    Array.from(insertion.element.children).find(c => c.tagName.toLowerCase() === 'uri');
                if (uriEl) {
                    result.uri = uriEl.textContent.trim();
                }

                const hashEl = insertion.element.querySelector('hash') ||
                    Array.from(insertion.element.children).find(c => c.tagName.toLowerCase() === 'hash');
                if (hashEl) {
                    result.hash = hashEl.textContent.trim();
                    result.hashMethod = hashEl.getAttribute('method') || '';
                }

                const formatEl = insertion.element.querySelector('format') ||
                    Array.from(insertion.element.children).find(c => c.tagName.toLowerCase() === 'format');
                if (formatEl) {
                    result.format = formatEl.textContent.trim();
                }
            }

            // element„Åå„Å™„ÅÑÂ†¥Âêà„ÅØraw XMLÊñáÂ≠óÂàó„Åã„ÇâÊ≠£Ë¶èË°®Áèæ„ÅßÊäΩÂá∫
            if (!result.uri && insertion.raw) {
                const uriMatch = insertion.raw.match(/<uri[^>]*>(.*?)<\/uri>/is);
                if (uriMatch) {
                    result.uri = uriMatch[1].trim();
                }
            }

            if (!result.hash && insertion.raw) {
                const hashMatch = insertion.raw.match(/<hash[^>]*method\s*=\s*["']([^"']+)["'][^>]*>(.*?)<\/hash>/is) ||
                    insertion.raw.match(/<hash[^>]*>(.*?)<\/hash>/is);
                if (hashMatch) {
                    if (hashMatch[2]) {
                        result.hash = hashMatch[2].trim();
                        result.hashMethod = hashMatch[1] || '';
                    } else {
                        result.hash = hashMatch[1].trim();
                    }
                }
            }

            if (!result.format && insertion.raw) {
                const formatMatch = insertion.raw.match(/<format[^>]*>(.*?)<\/format>/is);
                if (formatMatch) {
                    result.format = formatMatch[1].trim();
                }
            }

            return result;
        }

        // 4. „É°„Çø„Éá„Éº„ÇøÂèéÈõÜÈñ¢Êï∞ (‰øÆÊ≠£Áâà)
        function collectAllMetadata() {
            console.log('Starting metadata collection...');

            const metadata = {
                document: {},
                places: [],
                transitions: [],
                templates: [],
                instances: []
            };

            // „Éâ„Ç≠„É•„É°„É≥„ÉàÊÉÖÂ†±„ÇíÂèéÈõÜ
            const docInfo = document.getElementById('document-info');
            if (docInfo) {
                const tables = docInfo.querySelectorAll('table');
                tables.forEach(table => {
                    const rows = table.querySelectorAll('tr');
                    rows.forEach(row => {
                        const th = row.querySelector('th');
                        const td = row.querySelector('td');
                        if (th && td) {
                            metadata.document[th.textContent] = td.textContent;
                        }
                    });
                });
            }
            console.log('Document info collected:', Object.keys(metadata.document).length, 'items');

            // „Éé„Éº„ÉâÊÉÖÂ†±„ÇíÂèéÈõÜ
            if (window.nodes) {
                window.nodes.forEach(node => {
                    const nodeData = {
                        id: node.id,
                        type: node.type,
                        label: node.label
                    };

                    if (node.type === 'place') {
                        metadata.places.push(nodeData);
                    } else if (node.type === 'transition') {
                        metadata.transitions.push(nodeData);
                    }
                });
            }
            console.log('Places:', metadata.places.length, 'Transitions:', metadata.transitions.length);

            // „ÉÜ„É≥„Éó„É¨„Éº„ÉàÊÉÖÂ†±„ÇíÂèéÈõÜ (‰øÆÊ≠£: properties„Å®contents„ÇíÁµ±Âêà„ÄÅinsertions„ÇíËøΩÂä†)
            if (window.templateById) {
                window.templateById.forEach(tpl => {
                    const tplData = {
                        id: tpl.id,
                        role: tpl.role,
                        programId: tpl.programId,
                        uuid: tpl.uuid,
                        name: tpl.name,
                        description: tpl.description,
                        annotation: tpl.annotation,
                        placeRef: tpl.placeRef,
                        // ‚òÖ‰øÆÊ≠£: properties„Å®contents„ÇíÁµ±Âêà„Åó„Å¶„Éï„É©„ÉÉ„ÉàÂåñÔºàÈ†ÜÂ∫è„Çí‰øùÊåÅÔºâ
                        properties: flattenPropertiesForExport(tpl.properties || []),
                        contents: flattenPropertiesForExport(tpl.contents || []),
                        // ‚òÖËøΩÂä†: insertionsÊÉÖÂ†±„ÇíÊäΩÂá∫
                        insertions: (tpl.insertions || []).map(ins => extractInsertionInfo(ins))
                    };
                    metadata.templates.push(tplData);
                });
            }
            console.log('Templates collected:', metadata.templates.length);

            // „Ç§„É≥„Çπ„Çø„É≥„ÇπÊÉÖÂ†±„ÇíÂèéÈõÜ (‰øÆÊ≠£: properties„Å®contents„ÇíÁµ±Âêà„ÄÅinsertions„ÇíËøΩÂä†)
            if (window.instances) {
                window.instances.forEach(inst => {
                    const instData = {
                        id: inst.id,
                        role: inst.role,
                        templateRef: inst.templateRef,
                        uuid: inst.uuid,
                        name: inst.name,
                        description: inst.description,
                        annotation: inst.annotation,
                        // ‚òÖ‰øÆÊ≠£: properties„Å®contents„ÇíÁµ±Âêà„Åó„Å¶„Éï„É©„ÉÉ„ÉàÂåñÔºàÈ†ÜÂ∫è„Çí‰øùÊåÅÔºâ
                        properties: flattenPropertiesForExport(inst.properties || []),
                        contents: flattenPropertiesForExport(inst.contents || []),
                        // ‚òÖËøΩÂä†: insertionsÊÉÖÂ†±„ÇíÊäΩÂá∫
                        insertions: (inst.insertions || []).map(ins => extractInsertionInfo(ins))
                    };
                    metadata.instances.push(instData);
                });
            }
            console.log('Instances collected:', metadata.instances.length);

            return metadata;
        }

        // 5. ÈöéÂ±§ÊßãÈÄ†„ÇíÁ∂≠ÊåÅ„Åó„Åü„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆ„Éï„É©„ÉÉ„ÉàÂåñ (‰øÆÊ≠£Áâà: kind„Éï„Ç£„Éº„É´„Éâ„Çí‰øùÊåÅ)
        function flattenPropertiesForExport(items, parentPath = '', level = 0) {
            const result = [];

            items.forEach(item => {
                const currentPath = parentPath ? `${parentPath}.${item.key || item.name}` : (item.key || item.name);

                const flatItem = {
                    kind: item.kind || 'property',  // ‚òÖËøΩÂä†: kind„Éï„Ç£„Éº„É´„Éâ„Çí‰øùÊåÅ
                    level: level,
                    path: currentPath,
                    key: item.key || '',
                    name: item.name || '',
                    type: item.type || '',
                    description: item.description || '',
                    value: formatValue(item.value),
                    units: item.units || '',
                    formatString: item.fstring || ''
                };

                result.push(flatItem);

                // Â≠êË¶ÅÁ¥†„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
                if (item.children && item.children.length > 0) {
                    result.push(...flattenPropertiesForExport(item.children, currentPath, level + 1));
                }
            });

            return result;
        }

        function formatValue(value) {
            if (Array.isArray(value)) {
                return value.join(', ');
            }
            return value ? String(value) : '';
        }

        // 5-2. „Éá„Éº„Çø„ÅÆÊñáÂ≠óÊï∞„ÉÅ„Çß„ÉÉ„ÇØÈñ¢Êï∞
        function checkDataLengthLimits(metadata) {
            const MAX_CELL_LENGTH = 32767;
            const violations = [];

            // „Éâ„Ç≠„É•„É°„É≥„ÉàÊÉÖÂ†±„ÉÅ„Çß„ÉÉ„ÇØ
            Object.entries(metadata.document).forEach(([key, value]) => {
                const keyStr = String(key);
                const valStr = String(value);
                if (keyStr.length > MAX_CELL_LENGTH) {
                    violations.push({ location: 'Document Info (Key)', value: keyStr.substring(0, 100) + '...', length: keyStr.length });
                }
                if (valStr.length > MAX_CELL_LENGTH) {
                    violations.push({ location: 'Document Info (Value)', value: valStr.substring(0, 100) + '...', length: valStr.length });
                }
            });

            // Places/Transitions„ÉÅ„Çß„ÉÉ„ÇØ
            [...metadata.places, ...metadata.transitions].forEach((node, idx) => {
                ['id', 'type', 'label'].forEach(field => {
                    const val = String(node[field] || '');
                    if (val.length > MAX_CELL_LENGTH) {
                        violations.push({
                            location: `${node.type === 'place' ? 'Place' : 'Transition'} #${idx + 1} (${field})`,
                            value: val.substring(0, 100) + '...',
                            length: val.length
                        });
                    }
                });
            });

            // Templates„ÉÅ„Çß„ÉÉ„ÇØ
            metadata.templates.forEach((tpl, idx) => {
                ['id', 'role', 'programId', 'uuid', 'name', 'description', 'annotation', 'placeRef'].forEach(field => {
                    const val = String(tpl[field] || '');
                    if (val.length > MAX_CELL_LENGTH) {
                        violations.push({
                            location: `Template #${idx + 1} "${tpl.id}" (${field})`,
                            value: val.substring(0, 100) + '...',
                            length: val.length
                        });
                    }
                });

                // Template Properties„ÉÅ„Çß„ÉÉ„ÇØ
                tpl.properties.forEach((prop, pIdx) => {
                    ['path', 'key', 'name', 'type', 'description', 'value', 'units', 'formatString'].forEach(field => {
                        const val = String(prop[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Template "${tpl.id}" Property #${pIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });

                // Template Contents„ÉÅ„Çß„ÉÉ„ÇØ
                tpl.contents.forEach((cont, cIdx) => {
                    ['path', 'key', 'name', 'type', 'description', 'value', 'units', 'formatString'].forEach(field => {
                        const val = String(cont[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Template "${tpl.id}" Content #${cIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });

                // Template Insertions„ÉÅ„Çß„ÉÉ„ÇØ
                (tpl.insertions || []).forEach((ins, insIdx) => {
                    ['id', 'uri', 'hash', 'hashMethod', 'format'].forEach(field => {
                        const val = String(ins[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Template "${tpl.id}" Insertion #${insIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });
            });

            // Instances„ÉÅ„Çß„ÉÉ„ÇØ
            metadata.instances.forEach((inst, idx) => {
                ['id', 'role', 'templateRef', 'uuid', 'name', 'description', 'annotation'].forEach(field => {
                    const val = String(inst[field] || '');
                    if (val.length > MAX_CELL_LENGTH) {
                        violations.push({
                            location: `Instance #${idx + 1} "${inst.id}" (${field})`,
                            value: val.substring(0, 100) + '...',
                            length: val.length
                        });
                    }
                });

                // Instance Properties„ÉÅ„Çß„ÉÉ„ÇØ
                inst.properties.forEach((prop, pIdx) => {
                    ['path', 'key', 'name', 'type', 'description', 'value', 'units', 'formatString'].forEach(field => {
                        const val = String(prop[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Instance "${inst.id}" Property #${pIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });

                // Instance Contents„ÉÅ„Çß„ÉÉ„ÇØ
                inst.contents.forEach((cont, cIdx) => {
                    ['path', 'key', 'name', 'type', 'description', 'value', 'units', 'formatString'].forEach(field => {
                        const val = String(cont[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Instance "${inst.id}" Content #${cIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });

                // Instance Insertions„ÉÅ„Çß„ÉÉ„ÇØ
                (inst.insertions || []).forEach((ins, insIdx) => {
                    ['id', 'uri', 'hash', 'hashMethod', 'format'].forEach(field => {
                        const val = String(ins[field] || '');
                        if (val.length > MAX_CELL_LENGTH) {
                            violations.push({
                                location: `Instance "${inst.id}" Insertion #${insIdx + 1} (${field})`,
                                value: val.substring(0, 100) + '...',
                                length: val.length
                            });
                        }
                    });
                });
            });

            return violations;
        }

        // 6. ExcelÂá∫ÂäõÈñ¢Êï∞ÔºàÊñáÂ≠óÊï∞Ë∂ÖÈÅéÊôÇ„ÅØ„Ç®„ÇØ„Çπ„Éù„Éº„Éà‰∏≠Ê≠¢ÁâàÔºâ
        // 6. ExcelÂá∫ÂäõÈñ¢Êï∞(property+contentÁµ±ÂêàÁâà)
        function exportToExcel(metadata) {
            console.log('Starting Excel export with length validation...');

            if (typeof XLSX === 'undefined') {
                alert('Excel library (XLSX) is not loaded.');
                console.error('XLSX library not found!');
                return;
            }

            // „Éá„Éº„Çø„ÅÆÊñáÂ≠óÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
            console.log('Checking data length limits...');
            const violations = checkDataLengthLimits(metadata);

            if (violations.length > 0) {
                console.error('Data length violations found:', violations.length);

                // Ë©≥Á¥∞„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÁîüÊàê
                let errorMessage = `‚ùå Excel Export Failed\n\n`;
                errorMessage += `Excel has a limit of 32,767 characters per cell.\n`;
                errorMessage += `Found ${violations.length} field(s) exceeding this limit:\n\n`;

                // ÊúÄÂàù„ÅÆ5‰ª∂„ÇíË°®Á§∫
                violations.slice(0, 5).forEach((v, idx) => {
                    errorMessage += `${idx + 1}. ${v.location}\n`;
                    errorMessage += `   Length: ${v.length.toLocaleString()} characters\n`;
                    errorMessage += `   Preview: ${v.value}\n\n`;
                });

                if (violations.length > 5) {
                    errorMessage += `... and ${violations.length - 5} more violation(s)\n\n`;
                }

                errorMessage += `Suggestion: Try exporting to JSON format instead, which has no such limitation.`;

                // „Ç¢„É©„Éº„Éà„ÅßË°®Á§∫
                alert(errorMessage);

                // „Ç≥„É≥„ÇΩ„Éº„É´„Å´„ÇÇË©≥Á¥∞„ÇíÂá∫Âäõ
                console.error('=== Data Length Violations ===');
                violations.forEach(v => {
                    console.error(`Location: ${v.location}`);
                    console.error(`Length: ${v.length} characters`);
                    console.error(`Preview: ${v.value}`);
                    console.error('---');
                });

                throw new Error(`Cannot export to Excel: ${violations.length} field(s) exceed 32,767 character limit`);
            }

            console.log('‚úì All data within Excel cell length limits');

            const wb = XLSX.utils.book_new();
            const MAX_ROWS_PER_SHEET = 50000;

            try {
                // „Éâ„Ç≠„É•„É°„É≥„ÉàÊÉÖÂ†±„Ç∑„Éº„Éà
                const docData = Object.entries(metadata.document).map(([key, value]) => ({
                    'Item': key,
                    'Value': value
                }));
                if (docData.length > 0) {
                    console.log('Adding Document Info sheet...');
                    const wsDoc = XLSX.utils.json_to_sheet(docData);
                    XLSX.utils.book_append_sheet(wb, wsDoc, 'Document Info');
                }

                // Places„Ç∑„Éº„Éà
                if (metadata.places.length > 0) {
                    console.log('Adding Places sheet:', metadata.places.length, 'rows');
                    const wsPlaces = XLSX.utils.json_to_sheet(metadata.places);
                    XLSX.utils.book_append_sheet(wb, wsPlaces, 'Places');
                }

                // Transitions„Ç∑„Éº„Éà
                if (metadata.transitions.length > 0) {
                    console.log('Adding Transitions sheet:', metadata.transitions.length, 'rows');
                    const wsTrans = XLSX.utils.json_to_sheet(metadata.transitions);
                    XLSX.utils.book_append_sheet(wb, wsTrans, 'Transitions');
                }

                // Templates„Ç∑„Éº„Éà (Âü∫Êú¨ÊÉÖÂ†±)
                const templatesBasic = metadata.templates.map(t => ({
                    'ID': t.id,
                    'Role': t.role,
                    'Program ID': t.programId || '',
                    'UUID': t.uuid || '',
                    'Name': t.name || '',
                    'Description': t.description || '',
                    'Place Ref': t.placeRef || ''
                }));
                if (templatesBasic.length > 0) {
                    console.log('Adding Templates sheet:', templatesBasic.length, 'rows');
                    const wsTplBasic = XLSX.utils.json_to_sheet(templatesBasic);
                    XLSX.utils.book_append_sheet(wb, wsTplBasic, 'Templates');
                }

                // ‚òÖ‰øÆÊ≠£: Template Properties + Contents „ÇíÁµ±Âêà (È†ÜÂ∫è„Çí‰øùÊåÅ)
                const allTemplateData = [];
                metadata.templates.forEach(tpl => {
                    // properties„Å®contents„ÇíÁµ±Âêà„Åó„Å¶È†ÜÂ∫è„Çí‰øùÊåÅ
                    const combined = [...tpl.properties, ...tpl.contents];
                    combined.forEach(item => {
                        allTemplateData.push({
                            'Template ID': tpl.id,
                            'Kind': item.kind === 'property' ? 'Property' : 'Content',  // Á®ÆÂà•„ÇíËøΩÂä†
                            'Level': item.level,
                            'Path': item.path,
                            'Key': item.key,
                            // 'Name': item.name,
                            'Description': item.description,
                            'Type': item.type,
                            'Value': item.value,
                            'Units': item.units,
                            'FormatString': item.formatString
                        });
                    });
                });

                if (allTemplateData.length > 0) {
                    console.log('Adding Template Data (Properties+Contents) sheet:', allTemplateData.length, 'rows');

                    if (allTemplateData.length > MAX_ROWS_PER_SHEET) {
                        console.warn('Template Data exceeds max rows, splitting...');
                        const numSheets = Math.ceil(allTemplateData.length / MAX_ROWS_PER_SHEET);

                        for (let i = 0; i < numSheets; i++) {
                            const start = i * MAX_ROWS_PER_SHEET;
                            const end = Math.min((i + 1) * MAX_ROWS_PER_SHEET, allTemplateData.length);
                            const chunk = allTemplateData.slice(start, end);
                            const ws = XLSX.utils.json_to_sheet(chunk);
                            XLSX.utils.book_append_sheet(wb, ws, `TplData_${i + 1}`);
                        }
                    } else {
                        const wsTplData = XLSX.utils.json_to_sheet(allTemplateData);
                        XLSX.utils.book_append_sheet(wb, wsTplData, 'Template Data');
                    }
                }

                // ‚òÖËøΩÂä†: Template Insertions„Ç∑„Éº„Éà
                const templateInsertions = [];
                metadata.templates.forEach(tpl => {
                    (tpl.insertions || []).forEach(ins => {
                        templateInsertions.push({
                            'Template ID': tpl.id,
                            'Insertion ID': ins.id || '',
                            'URI': ins.uri || '',
                            'Hash': ins.hash || '',
                            'Hash Method': ins.hashMethod || '',
                            'Format': ins.format || ''
                        });
                    });
                });
                if (templateInsertions.length > 0) {
                    console.log('Adding Template Insertions sheet:', templateInsertions.length, 'rows');
                    const wsTplIns = XLSX.utils.json_to_sheet(templateInsertions);
                    XLSX.utils.book_append_sheet(wb, wsTplIns, 'Template Insertions');
                }

                // Instances„Ç∑„Éº„Éà
                const instancesBasic = metadata.instances.map(i => ({
                    'ID': i.id,
                    'Role': i.role,
                    'Template Ref': i.templateRef || '',
                    'UUID': i.uuid || '',
                    'Name': i.name || '',
                    'Description': i.description || ''
                }));
                if (instancesBasic.length > 0) {
                    console.log('Adding Instances sheet:', instancesBasic.length, 'rows');
                    const wsInstBasic = XLSX.utils.json_to_sheet(instancesBasic);
                    XLSX.utils.book_append_sheet(wb, wsInstBasic, 'Instances');
                }

                // ‚òÖ‰øÆÊ≠£: Instance Properties + Contents „ÇíÁµ±Âêà (È†ÜÂ∫è„Çí‰øùÊåÅ)
                const allInstanceData = [];
                metadata.instances.forEach(inst => {
                    // properties„Å®contents„ÇíÁµ±Âêà„Åó„Å¶È†ÜÂ∫è„Çí‰øùÊåÅ
                    const combined = [...inst.properties, ...inst.contents];
                    combined.forEach(item => {
                        allInstanceData.push({
                            'Instance ID': inst.id,
                            'Kind': item.kind === 'property' ? 'Property' : 'Content',  // Á®ÆÂà•„ÇíËøΩÂä†
                            'Level': item.level,
                            'Path': item.path,
                            'Key': item.key,
                            // 'Name': item.name,
                            'Description': item.description,
                            'Type': item.type,
                            'Value': item.value,
                            'Units': item.units,
                            'FormatString': item.formatString
                        });
                    });
                });

                if (allInstanceData.length > 0) {
                    console.log('Adding Instance Data (Properties+Contents) sheet:', allInstanceData.length, 'rows');

                    if (allInstanceData.length > MAX_ROWS_PER_SHEET) {
                        console.warn('Instance Data exceeds max rows, splitting...');
                        const numSheets = Math.ceil(allInstanceData.length / MAX_ROWS_PER_SHEET);

                        for (let i = 0; i < numSheets; i++) {
                            const start = i * MAX_ROWS_PER_SHEET;
                            const end = Math.min((i + 1) * MAX_ROWS_PER_SHEET, allInstanceData.length);
                            const chunk = allInstanceData.slice(start, end);
                            const ws = XLSX.utils.json_to_sheet(chunk);
                            XLSX.utils.book_append_sheet(wb, ws, `InstData_${i + 1}`);
                        }
                    } else {
                        const wsInstData = XLSX.utils.json_to_sheet(allInstanceData);
                        XLSX.utils.book_append_sheet(wb, wsInstData, 'Instance Data');
                    }
                }

                // ‚òÖËøΩÂä†: Instance Insertions„Ç∑„Éº„Éà
                const instanceInsertions = [];
                metadata.instances.forEach(inst => {
                    (inst.insertions || []).forEach(ins => {
                        instanceInsertions.push({
                            'Instance ID': inst.id,
                            'Insertion ID': ins.id || '',
                            'URI': ins.uri || '',
                            'Hash': ins.hash || '',
                            'Hash Method': ins.hashMethod || '',
                            'Format': ins.format || ''
                        });
                    });
                });
                if (instanceInsertions.length > 0) {
                    console.log('Adding Instance Insertions sheet:', instanceInsertions.length, 'rows');
                    const wsInstIns = XLSX.utils.json_to_sheet(instanceInsertions);
                    XLSX.utils.book_append_sheet(wb, wsInstIns, 'Instance Insertions');
                }

                // „Éï„Ç°„Ç§„É´ÂêçÁîüÊàê
                const fileName = `MaiML_Metadata_${new Date().toISOString().slice(0, 10)}.xlsx`;

                console.log('Writing Excel file:', fileName);
                console.log('Total sheets:', wb.SheetNames.length);

                // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                XLSX.writeFile(wb, fileName);
                console.log('Excel file successfully created!');

            } catch (error) {
                console.error('Error during Excel generation:', error);
                throw error;
            }
        }

        // 7. JSONÂá∫ÂäõÈñ¢Êï∞
        function exportToJSON(metadata) {
            console.log('Starting JSON export...');

            // ÈöéÂ±§ÊßãÈÄ†„ÇíÂæ©ÂÖÉ„Åó„ÅüJSON„Çí‰ΩúÊàê
            const output = {
                document: metadata.document,
                places: metadata.places,
                transitions: metadata.transitions,
                templates: metadata.templates.map(tpl => ({
                    id: tpl.id,
                    role: tpl.role,
                    programId: tpl.programId,
                    uuid: tpl.uuid,
                    name: tpl.name,
                    description: tpl.description,
                    annotation: tpl.annotation,
                    placeRef: tpl.placeRef,
                    properties: reconstructHierarchy(tpl.properties),
                    contents: reconstructHierarchy(tpl.contents),
                    // ‚òÖËøΩÂä†: insertionsÊÉÖÂ†±
                    insertions: tpl.insertions || []
                })),
                instances: metadata.instances.map(inst => ({
                    id: inst.id,
                    role: inst.role,
                    templateRef: inst.templateRef,
                    uuid: inst.uuid,
                    name: inst.name,
                    description: inst.description,
                    annotation: inst.annotation,
                    properties: reconstructHierarchy(inst.properties),
                    contents: reconstructHierarchy(inst.contents),
                    // ‚òÖËøΩÂä†: insertionsÊÉÖÂ†±
                    insertions: inst.insertions || []
                }))
            };

            const jsonStr = JSON.stringify(output, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const fileName = `MaiML_Metadata_${new Date().toISOString().slice(0, 10)}.json`;

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();

            URL.revokeObjectURL(url);
            console.log('JSON file downloaded:', fileName);
        }

        // CSVÂá∫ÂäõÈñ¢Êï∞
        function exportToCSV(metadata) {
            console.log('Starting CSV export...');

            const CSV_BOM = '\uFEFF'; // UTF-8 BOM for Excel compatibility
            let csvContent = CSV_BOM;

            // Helper function: CSV„Çª„É´„ÅÆ„Ç®„Çπ„Ç±„Éº„Éó
            function escapeCSV(value) {
                if (value == null) return '';
                const str = String(value);
                // „ÉÄ„Éñ„É´„ÇØ„Ç©„Éº„Éà„ÄÅ„Ç´„É≥„Éû„ÄÅÊîπË°å„ÇíÂê´„ÇÄÂ†¥Âêà„ÅØ„ÇØ„Ç©„Éº„Éà„ÅßÂõ≤„ÇÄ
                if (str.includes('"') || str.includes(',') || str.includes('\n') || str.includes('\r')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            }

            // Helper function: ÈÖçÂàó„ÇíCSVË°å„Å´Â§âÊèõ
            function arrayToCSVRow(arr) {
                return arr.map(escapeCSV).join(',') + '\n';
            }

            // 1. Document Info
            csvContent += '\n=== Document Info ===\n';
            csvContent += arrayToCSVRow(['Item', 'Value']);
            Object.entries(metadata.document).forEach(([key, value]) => {
                csvContent += arrayToCSVRow([key, value]);
            });

            // 2. Places
            if (metadata.places.length > 0) {
                csvContent += '\n=== Places ===\n';
                csvContent += arrayToCSVRow(['ID', 'Type', 'Label']);
                metadata.places.forEach(p => {
                    csvContent += arrayToCSVRow([p.id, p.type, p.label]);
                });
            }

            // 3. Transitions
            if (metadata.transitions.length > 0) {
                csvContent += '\n=== Transitions ===\n';
                csvContent += arrayToCSVRow(['ID', 'Type', 'Label']);
                metadata.transitions.forEach(t => {
                    csvContent += arrayToCSVRow([t.id, t.type, t.label]);
                });
            }

            // 4. Templates (Basic)
            if (metadata.templates.length > 0) {
                csvContent += '\n=== Templates ===\n';
                csvContent += arrayToCSVRow(['ID', 'Role', 'Program ID', 'UUID', 'Name', 'Description', 'Place Ref']);
                metadata.templates.forEach(t => {
                    csvContent += arrayToCSVRow([
                        t.id, t.role, t.programId || '', t.uuid || '',
                        t.name || '', t.description || '', t.placeRef || ''
                    ]);
                });
            }

            // 5. Template Data (Properties + Contents)
            const allTemplateData = [];
            metadata.templates.forEach(tpl => {
                const combined = [...tpl.properties, ...tpl.contents];
                combined.forEach(item => {
                    allTemplateData.push([
                        tpl.id,
                        item.kind === 'property' ? 'Property' : 'Content',
                        item.level,
                        item.path,
                        item.key,
                        item.name,
                        item.type,
                        item.description,
                        item.value,
                        item.units,
                        item.formatString
                    ]);
                });
            });

            if (allTemplateData.length > 0) {
                csvContent += '\n=== Template Data (Properties + Contents) ===\n';
                csvContent += arrayToCSVRow([
                    'Template ID', 'Kind', 'Level', 'Path', 'Key', 'Name',
                    'Type', 'Description', 'Value', 'Units', 'Format'
                ]);
                allTemplateData.forEach(row => {
                    csvContent += arrayToCSVRow(row);
                });
            }

            // 5-2. Template Insertions
            const templateInsertions = [];
            metadata.templates.forEach(tpl => {
                (tpl.insertions || []).forEach(ins => {
                    templateInsertions.push([
                        tpl.id,
                        ins.id || '',
                        ins.uri || '',
                        ins.hash || '',
                        ins.hashMethod || '',
                        ins.format || ''
                    ]);
                });
            });
            if (templateInsertions.length > 0) {
                csvContent += '\n=== Template Insertions ===\n';
                csvContent += arrayToCSVRow([
                    'Template ID', 'Insertion ID', 'URI', 'Hash', 'Hash Method', 'Format'
                ]);
                templateInsertions.forEach(row => {
                    csvContent += arrayToCSVRow(row);
                });
            }

            // 6. Instances (Basic)
            if (metadata.instances.length > 0) {
                csvContent += '\n=== Instances ===\n';
                csvContent += arrayToCSVRow(['ID', 'Role', 'Template Ref', 'UUID', 'Name', 'Description']);
                metadata.instances.forEach(i => {
                    csvContent += arrayToCSVRow([
                        i.id, i.role, i.templateRef || '', i.uuid || '',
                        i.name || '', i.description || ''
                    ]);
                });
            }

            // 7. Instance Data (Properties + Contents)
            const allInstanceData = [];
            metadata.instances.forEach(inst => {
                const combined = [...inst.properties, ...inst.contents];
                combined.forEach(item => {
                    allInstanceData.push([
                        inst.id,
                        item.kind === 'property' ? 'Property' : 'Content',
                        item.level,
                        item.path,
                        item.key,
                        item.name,
                        item.type,
                        item.description,
                        item.value,
                        item.units,
                        item.formatString
                    ]);
                });
            });

            if (allInstanceData.length > 0) {
                csvContent += '\n=== Instance Data (Properties + Contents) ===\n';
                csvContent += arrayToCSVRow([
                    'Instance ID', 'Kind', 'Level', 'Path', 'Key', 'Name',
                    'Type', 'Description', 'Value', 'Units', 'Format'
                ]);
                allInstanceData.forEach(row => {
                    csvContent += arrayToCSVRow(row);
                });
            }

            // 7-2. Instance Insertions
            const instanceInsertions = [];
            metadata.instances.forEach(inst => {
                (inst.insertions || []).forEach(ins => {
                    instanceInsertions.push([
                        inst.id,
                        ins.id || '',
                        ins.uri || '',
                        ins.hash || '',
                        ins.hashMethod || '',
                        ins.format || ''
                    ]);
                });
            });
            if (instanceInsertions.length > 0) {
                csvContent += '\n=== Instance Insertions ===\n';
                csvContent += arrayToCSVRow([
                    'Instance ID', 'Insertion ID', 'URI', 'Hash', 'Hash Method', 'Format'
                ]);
                instanceInsertions.forEach(row => {
                    csvContent += arrayToCSVRow(row);
                });
            }

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const fileName = `MaiML_Metadata_${new Date().toISOString().slice(0, 10)}.csv`;

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();

            URL.revokeObjectURL(url);
            console.log('CSV file downloaded:', fileName);
        }

        // 8. ÈöéÂ±§ÊßãÈÄ†„ÅÆÂæ©ÂÖÉ
        function reconstructHierarchy(flatItems) {
            if (!flatItems || flatItems.length === 0) return [];

            const root = [];
            const stack = [{ level: -1, children: root }];

            flatItems.forEach(item => {
                const newItem = {
                    'key': item.key,
                    // name: item.name,
                    description: item.description,
                    'type': item.type,
                    value: item.value,
                    'units': item.units,
                    'formatString': item.formatString,
                    children: []
                };

                // „Çπ„Çø„ÉÉ„ÇØ„ÇíË™øÊï¥„Åó„Å¶ÈÅ©Âàá„Å™Ë¶™„ÇíË¶ã„Å§„Åë„Çã
                while (stack.length > 0 && stack[stack.length - 1].level >= item.level) {
                    stack.pop();
                }

                // ÁèæÂú®„ÅÆË¶™„ÅÆÂ≠ê„Å®„Åó„Å¶ËøΩÂä†
                const parent = stack[stack.length - 1];
                parent.children.push(newItem);

                // Êñ∞„Åó„ÅÑ„Ç¢„Ç§„ÉÜ„É†„Çí„Çπ„Çø„ÉÉ„ÇØ„Å´ËøΩÂä†
                stack.push({ level: item.level, children: newItem.children });
            });

            return root;
        }

        // 9. ExportÂÆüË°åÈñ¢Êï∞
        function executeExport(format) {
            console.log('Executing export with format:', format);
            const statusDiv = document.getElementById('exportStatus');

            try {
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'var(--accent)';
                statusDiv.style.color = '#fff';
                statusDiv.textContent = '‚è≥ Collecting metadata...';

                const metadata = collectAllMetadata();

                if (format === 'excel') {
                    statusDiv.textContent = '‚è≥ Generating Excel file...';
                    setTimeout(() => {
                        exportToExcel(metadata);
                        statusDiv.style.background = 'var(--accent2)';
                        statusDiv.textContent = '‚úÖ Excel file exported successfully!';
                        setTimeout(closeExportModal, 1500);
                    }, 100);
                } else if (format === 'json') {
                    statusDiv.textContent = '‚è≥ Generating JSON file...';
                    setTimeout(() => {
                        exportToJSON(metadata);
                        statusDiv.style.background = 'var(--accent2)';
                        statusDiv.textContent = '‚úÖ JSON file exported successfully!';
                        setTimeout(closeExportModal, 1500);
                    }, 100);
                } else if (format === 'csv') {
                    statusDiv.textContent = '‚è≥ Generating CSV file...';
                    setTimeout(() => {
                        try {
                            exportToCSV(metadata);
                            statusDiv.style.background = 'var(--accent2)';
                            statusDiv.textContent = '‚úÖ CSV file exported successfully!';
                            setTimeout(closeExportModal, 1500);
                        } catch (error) {
                            console.error('CSV export error:', error);
                            statusDiv.style.background = 'var(--warn)';
                            statusDiv.textContent = '‚ùå CSV export failed: ' + error.message;
                        }
                    }, 200);
                }
            } catch (error) {
                console.error('Export error:', error);
                statusDiv.style.background = 'var(--warn)';
                statusDiv.style.color = '#fff';
                statusDiv.textContent = '‚ùå Export failed: ' + error.message;
            }
        }

        console.log('‚úÖ MaiML Metadata Export feature loaded successfully!');
    </script>

</body>

</html>